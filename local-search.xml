<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Once Model Determined, Once Feature Importance Determined</title>
    <link href="/2024/07/15/Once%20Model%20Determined,%20Once%20Feature%20Importance%20Determined/"/>
    <url>/2024/07/15/Once%20Model%20Determined,%20Once%20Feature%20Importance%20Determined/</url>
    
    <content type="html"><![CDATA[<p>The concept of feature importance has been around for a long time,but it remains somewhat abstract. Many people believe that featureimportance is fixed regardless of the learning model used, or that itvaries based on the feature selection methods employed. However, featureimportance is actually determined by the learning model itself.</p><span id="more"></span><h2 id="foundation">Foundation</h2><p>We have the following lemma holds:</p><p>Let <span class="math inline">\(X_1, X_2, \ldots, X_n\)</span> beindependent and identically distributed random variables following acertain distribution. Define the partial sums <span class="math inline">\(S(k) = \sum_{i=1}^{k} X_i\)</span> for $ k = 1, 2,, n $. Let <span class="math inline">\(A_n = \{ S(1), S(2), \ldots, S(n)\}\)</span> and <span class="math inline">\(B_n = \{ 1, 2, \ldots, n\}\)</span>.</p><p>Then, we claim that</p><p><span class="math display">\[\lim_{n \to \infty} r(A_n, B_n) \in \{-1, 1\},\]</span> where <span class="math inline">\(r(A_n, B_n)\)</span> denotesthe Spearman correlation coefficient between the sets <span class="math inline">\(A_n\)</span> and <span class="math inline">\(B_n\)</span>.</p><p>I have not found a proof or relevant materials about this, butexperimental results show it holds for every cases I tried. You can runthe following code and explore this lemma.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> pearsonr<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">distribution</span>(<span class="hljs-params">lam=<span class="hljs-number">0.01</span></span>):<br><span class="hljs-comment"># Change this function to whatever distribution you like</span><br>    <span class="hljs-keyword">return</span> np.random.poisson(lam)<br><br>sum_value = <span class="hljs-number">0</span><br>results = []  <br>max_iter = <span class="hljs-number">100000</span>  <span class="hljs-comment"># Change this value to explore the changes of linearity level with iterations</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, max_iter):<br>    sum_value += distribution()<br>    results.append(sum_value)<br><br>plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, max_iter), results)<br>plt.xlabel(<span class="hljs-string">&quot;Iteration&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Cumulative Sum&quot;</span>)<br>plt.title(<span class="hljs-string">&quot;Cumulative Sum of Poisson Random Values&quot;</span>)<br>plt.show()<br><br>iterations = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, max_iter)<br>correlation, _ = pearsonr(results, iterations)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Pearson correlation coefficient: <span class="hljs-subst">&#123;correlation&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="feature-selection">Feature Selection</h2><p>Specifically speaking, here we are talking about wrapper featureselection, that we treat the criterion as a black box. The input iscertain feature subset and the output is the evaluation metric (likeclassification accuracy) of the learning algorithm.</p><p>There exists a strong relationship between wrapper feature selectionand the above lemma. Suppose we have a weight array that records theimportance values of each feature. These importance values can bedefined as the selection probabilities of the corresponding features.When we sample a feature subset based on this weight array, the learningalgorithm and training data remain constant, thereby determining theblack box criterion. Consequently, each feature adheres to a certain(and complex) selected probability distribution relative to itscontribution to the criterion. The key distinction is that the abovelemma is one-dimensional, while the feature space is multi-dimensional.Nonetheless, the margin distribution is determined. For any individualfeature, it follows a specific distribution that relates its selectionprobability to the expected value of the criterion. Thus, throughiterative processes, we can update the feature weights based on thedifferences in criterion values, effectively aligning with theprinciples outlined in the above lemma.</p><p>​ Let's use more rigor language to describe it. Assume we have adataset with <span class="math inline">\(n\)</span> features <span class="math inline">\(F_1, F_2, \dots,F_n\)</span>. The feature subsetis defined by a binary array <span class="math inline">\(X\in { \{0,1\}}^n\)</span>. The criterion <span class="math inline">\(f(*):{ \{0,1\}}^n \rightarrow [0,1]\)</span> is used to evaluate the quality of input<span class="math inline">\(X\)</span>. We aim to find the best featuresubset <span class="math inline">\(X^*\)</span> to make the criterionmaximum. <span class="math display">\[X^*=\max_{X\in { \{0,1\} }^n} f(X)\]</span> Some question may be raised: if <span class="math inline">\(f(*)\)</span> is a black box, why can we find abetter solution than randomly guess? Actually there exists some clue forfind better solution, for example, a feature subset contains a "great"feature is more possible to have a higher quality. This is like why KNNworks to some extent.</p><p>Get in back to the point, we introduce a weight array <span class="math inline">\(W\in [0,1]^n\)</span> to record selectedprobability of features, as well as it represents the featureimportance. We decide which features are selected based on <span class="math inline">\(W\)</span>, i.e. <span class="math display">\[P(X_i=1)=W_i \quad (i=1,2,\dots n)\]</span> Following I use <span class="math inline">\(W_i^{(t)}\)</span>to denote the selected probability of <span class="math inline">\(i\)</span>-th feature in <span class="math inline">\(t\)</span>-th iteration. Based on our assumption,feature with higher weight contributes more to criterion. Therefore,weight array can updated as follows: <span class="math display">\[W_i^{(m)}=\sum_{t=1}^{m-1} \alpha (f(X^{(t+1)})-f(X^{(t)}))\odotX_i^{(t+1)}.\]</span> The meaning of the updating of <span class="math inline">\(W\)</span> is: if a feature is selected (<span class="math inline">\(X_i = 1\)</span>), the criterion value isconsidered as partly affected by this feature. If it has positive effectto the criterion, the criterion value is more likely to be higher thanwhen it is not selected. i.e. <span class="math inline">\(f(X^{(t+1)})-f(X^{(t)})\)</span> is more likely tobe a value greater than 0. Otherwise it has negative effect to thecriterion, the the criterion value is more likely to be lower than whenit is not selected. To avoid <span class="math inline">\(W\)</span>being out of range <span class="math inline">\([0,1]\)</span>, we need aconstant parameter <span class="math inline">\(\alpha\)</span> to limitits range.</p><p>Interestingly, the updating of <span class="math inline">\(W\)</span>follows the above lemma. This is determined by the dataset and learningmodel. Since the black box criterion is determined by these two factors,the distribution that each feature follows relating its selectionprobability to the expected value of the criterion is determined. Thesample code is as follows.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> linear_model<br><span class="hljs-keyword">import</span> sklearn.svm <span class="hljs-keyword">as</span> svm<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingClassifier<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_wine<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>data = load_wine()<br><br>X = pd.DataFrame(data.data, columns=data.feature_names)<br>y = pd.Series(data.target)<br><br>model_list = &#123;<br>    <span class="hljs-string">&#x27;lr&#x27;</span>: linear_model.LogisticRegression(solver=<span class="hljs-string">&#x27;sag&#x27;</span>, multi_class=<span class="hljs-string">&#x27;auto&#x27;</span>, max_iter=<span class="hljs-number">1000</span>),<br>    <span class="hljs-string">&#x27;svm&#x27;</span>: svm.SVC(class_weight=<span class="hljs-string">&#x27;balanced&#x27;</span>, probability=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">42</span>),<br>    <span class="hljs-string">&#x27;knn&#x27;</span>: KNeighborsClassifier(n_neighbors=<span class="hljs-number">5</span>),<br>    <span class="hljs-string">&#x27;gnb&#x27;</span>: GaussianNB(),<br>    <span class="hljs-string">&#x27;dt&#x27;</span>: DecisionTreeClassifier(max_depth=<span class="hljs-number">10</span>),<br>    <span class="hljs-string">&#x27;gbt&#x27;</span>: GradientBoostingClassifier(),<br>    <span class="hljs-string">&#x27;rf&#x27;</span>: RandomForestClassifier(max_depth=<span class="hljs-number">5</span>, n_estimators=<span class="hljs-number">50</span>)<br>&#125;<br><br>model_name = <span class="hljs-string">&#x27;knn&#x27;</span><br>max_epoch = <span class="hljs-number">1000</span><br><br>model = model_list[model_name]<br><br>x = np.array([<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(X.columns))<br>w = np.array([<span class="hljs-number">0.5</span>] * <span class="hljs-built_in">len</span>(X.columns))<br>W = np.zeros((max_epoch, <span class="hljs-built_in">len</span>(X.columns)))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">x</span>):<br>    x = [<span class="hljs-built_in">bool</span>(element) <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> x]<br>    X_selected = X.iloc[:, x]<br>    model = model_list[model_name]<br>    model.fit(X_selected, y)<br>    <span class="hljs-keyword">return</span> model.score(X_selected, y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sample</span>(<span class="hljs-params">x, w</span>):<br>    mutated_x = x.copy()<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        <span class="hljs-keyword">if</span> np.random.random() &lt; w[index]:<br>            mutated_x[index] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            mutated_x[index] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> mutated_x<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_epoch):<br>    f_ori = evaluate(x)<br>    x = sample(x, w)<br>    f_new = evaluate(x)<br>    w += x * (f_new - f_ori) * <span class="hljs-number">0.01</span><br>    W[i] = w<br><br>fig, ax = plt.subplots(dpi=<span class="hljs-number">300</span>)<br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(W[<span class="hljs-number">0</span>])):<br>    ax.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(W)), W[:, column], label=<span class="hljs-string">f&#x27;Feature <span class="hljs-subst">&#123;column&#125;</span>&#x27;</span>, linewidth=<span class="hljs-number">0.6</span>)<br><br>ax.legend(loc=<span class="hljs-string">&#x27;center left&#x27;</span>, bbox_to_anchor=(<span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>))<br>plt.xlabel(<span class="hljs-string">&#x27;Iteration count&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Selection probability of each feature&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Feature Selection Probability Over Iterations&#x27;</span>)<br>plt.show<br></code></pre></td></tr></table></figure><p>The result is shown in the following figure.</p><p><img src="wine.png" style="zoom:30%;"></p><p>The value curves in <span class="math inline">\(W\)</span> changelinearly with each iteration. What's more, they show clear differencesin slope. Some features have a high positive slope while some have ahigh negative slope. This phenomenon can be attributed to the relativeimportance of the features. You can try different datasets andalgorithms. And you will find only these two factors can affect thecurve slope. Repeating experiments on a single dataset will yieldconsistently similar results.</p><h2 id="conclusion">Conclusion</h2><p>This article describes a linear phenomenon in the representation offeature importance, which is essentially a property of independent andidentically distributed random walks. Furthermore, the selectionprobabilities of the features exhibit significant differences in slope,indicating variations in their importance. This demonstrates thatfeature importance is objectively present and has been determined by thedata and the learning algorithm.</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>Feature Engineering</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Troubles in Vessel Segmentation</title>
    <link href="/2024/04/26/Troubles%20in%20Vessel%20Segmentation/"/>
    <url>/2024/04/26/Troubles%20in%20Vessel%20Segmentation/</url>
    
    <content type="html"><![CDATA[<p>​ Like most researches in CV field, vessel segmentation faces severalproblems coming from unexplainability. Today I'd like to present some ofthem.</p><span id="more"></span><h2 id="what-is-vessel-segmentation">What is Vessel Segmentation</h2><p>The target of vessel segmentation is as its name suggests. We want toextract vessel structure from original CT image.</p><p><img src="task.png" style="zoom:47%;"></p><p>The characteristic of vessel segmentation is the vessel structure ishard to distinguish from original image. Consequently, there are oftenproblems such as lost fragments, discontinuities, and excessive noise inthe prediction results.</p><p><img src="comparison.png" style="zoom:57%;"></p><h2 id="structural-information">Structural information</h2><p>This phrase seems to be the most popular used in the field of vesselsegmentation. To clarify this concept, let's appreciate some referencesfirst.</p><ul><li><p>Pan et al. [1] thought 3D Unet <strong>ignores global structureinformation</strong>. They proposed the model involves a multi-scalefeature interaction between the U-Net and transformer modules, ensuringthe model can utilize both <strong>local and global structureinformation</strong>.</p></li><li><p>Wu et al. [2] incorporated self-attention block to U-Net tocapture <strong>global structure information</strong>.</p></li><li><p>Zhao et al. [3] combined graph attention with U-Net to capture<strong>global structure information</strong> . Initially they employedU-Net for segmentation, then utilized SLIC to generate super-voxels asgraph nodes and calculate edge weights based on theirdistances.</p></li><li><p>Dong et al. [4] replaced the conventional skip connection with anovel attention-guided feature fusion module, which attempted toadaptively identify and select the most discriminative <strong>semanticand spatial information</strong> to segment CA from surrounding veinsand noise.</p></li><li><p>Wu et al. [5] introduced the double attention block to capture<strong>long-range features</strong>.</p></li></ul><p>Intuitively, structural information or long-range features refer tothe relationships between two non-adjacent voxels. However, when usingan attention mechanism to compute the association between two adjacentvoxels, we are essentially determining this based on their spatialpositions. Given that vessels can take on a variety of shapes in space,how can we ensure that our approach generalizes across all cases? Ibelieve that relying solely on attention mechanisms and convolutionalnetworks is insufficient for achieving efficient vessel segmentation,and they do not address the three issues mentioned above.</p><h2 id="references">References</h2><p>[1] Chengwei Pan, Baolian Qi, Gangming Zhao, Jiaheng Liu, ChaoweiFang, Dingwen Zhang, and Jinpeng Li. Deep 3d vessel segmentation basedon cross transformer network. In 2022 IEEE international conference onbioinformatics and biomedicine (BIBM), pages 1115–1120. IEEE, 2022</p><p>[2] Yanan Wu, Shouliang Qi, Meihuan Wang, Shuiqing Zhao, Haowen Pang,Jiaxuan Xu, Long Bai, and Hongliang Ren. Transformer-based 3d u-net forpulmonary vessel segmentation and artery-vein separation from ct images.Medical &amp; Biological Engineering &amp; Computing, 61(10):2649–2663,2023.</p><p>[3] Gangming Zhao, Kongming Liang, Chengwei Pan, Fandong Zhang,Xianpeng Wu, Xinyang Hu, and Yizhou Yu. Graph convolution basedcross-network multiscale feature fusion for deep vessel segmentation.IEEE Transactions on Medical Imaging, 42(1):183–195, 2022.10</p><p>[4] Caixia Dong, Songhua Xu, Duwei Dai, Yizhi Zhang, Chunyan Zhang,and Zongfang Li. A novel multi-attention, multi-scale 3d deep networkfor coronary artery segmentation. Medical Image Analysis, 85:102745,2023</p><p>[5] Yanan Wu, Shouliang Qi, Meihuan Wang, Shuiqing Zhao, Haowen Pang,Jiaxuan Xu, Long Bai, and Hongliang Ren. Transformer-based 3d u-net forpulmonary vessel segmentation and artery-vein separation from ct images.Medical &amp; Biological Engineering &amp; Computing, 61(10):2649–2663,2023.</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Computer Vision</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Causal Inference</title>
    <link href="/2023/09/10/Causal%20Inference/"/>
    <url>/2023/09/10/Causal%20Inference/</url>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="introduction">Introduction</h2><p>What exactly is machine learning? What can we derive from data? Howcan we ensure that the conclusions we draw are correct? To address thesequestions, we need to move beyond simple correlation analysis and delveinto causal analysis. For instance, we can collect data on whetherindividuals smoke and whether they develop lung cancer, then use aclassification model to predict the incidence of lung cancer orcalculate the correlation between smoking and lung cancer to persuadethe public. However, why don't we predict smoking rates based on lungcancer? Clearly, this would be a meaningless research objective. But howdo we know it's meaningless to the extent that it seems "obvious"? Thepremise for this conclusion is our common understanding that smoking maylead to lung cancer, while lung cancer is not a cause of smoking.Whether we're obtaining the probability of developing lung cancer undersmoking conditions or proving a correlation between smoking and lungcancer, our conclusions rely on common sense reasoning. In a narrowsense, models that require human involvement in reasoning are notperfect algorithms, just as using an abacus is to using a calculator. Ina broader sense, we cannot always confidently infer correct conclusionsfrom correlations; they are not always as straightforward as the case ofsmoking and lung cancer, as illustrated by the examples below.</p><h3 id="simpson-paradox">Simpson Paradox</h3><p>A hospital has reported the treatment effects of a certain medicationon patients, as shown in the table below.</p><p><img src="1.png"></p><p>From the final results, it appears that the cure rate without themedication is 5% higher than with it. Does this imply that not using themedication is better? However, if we separate the data by gender, wefind that among males, the cure rate with the medication is 6% higherthan without it, and among females, it’s 4% higher. Does this indicatethat using the medication is better? The reason for this discrepancylies in the fact that the overall cure rate for females is significantlylower than for males, and the medication usage rate among females isnotably higher. Consequently, in the medication group, females dominate,while in the non-medication group, males dominate. This results in thehigher cure rate of the non-medication group being primarily due tomales who did not use the medication. Symbolically, this can bedescribed as: <span class="math display">\[\frac{a_1}{b_1}&gt;\frac{a_2}{b_2},\frac{a_3}{b_3}&gt;\frac{a_4}{b_4}\not\equiv\frac{a_1+a_3}{b_1+b_3}&gt;\frac{a_2+a_4}{b_2+b_4}\]</span> Consider that when faced with such relationships in a dataset,we can create a highly accurate predictive model for whether a patientis cured and select a feature subset that includes both medication useand gender. However, can these lead to the conclusion that themedication improves cure rates? No, this issue transcends correlationand delves into causality. We need more sophisticated algorithms toaddress such problems.</p><h3 id="correlation-and-causation">Correlation and Causation</h3><p>Correlation reflects the superficial phenomenon of causation. Becausethere is a causal relationship between variables, they exhibitcorrelation. Conversely, does correlation between variables necessarilyimply a causal relationship? This question is quite controversial. Here,I will provide some definitions to explain why I believe that correlatedvariables must have a causal relationship.</p><p><strong>Stable Data</strong>: Data that consistently fits a certaindistribution over a long period is referred to as stable data.</p><p><strong>Correlation</strong>: If certain variables in stable data arenot independent, they are said to be correlated.</p><p><strong>Causation</strong>: If forcibly changing the value ofvariable A results in a change in the value of variable B, whileforcibly changing the value of variable B does not lead to a change invariable A, then A and B are said to have causation, with A as the causeand B as the effect. In a Directed Acyclic Graph (DAG), variables arerepresented as nodes, and directed edges point from cause nodes toeffect nodes.</p><p><strong>Causal Relationship</strong>: Sufficient conditions for acausal relationship between variables A and B include the following:</p><ol type="1"><li>A and B have a causal relationship.</li><li>A and B share a common cause, meaning A and B are descendants of thesame cause node.</li></ol><p>Based on the definitions above, having a causal relationship andhaving correlation are necessary and sufficient conditions. For example,the following data shows the investment in technology in America and thenumber of suicides.</p><p><img src="2.png"></p><p>（More examples can be found in <a href="https://www.tylervigen.com/spurious-correlations">SpuriousCorrelations (tylervigen.com)</a>）</p><p>The data above does not meet the definition of stable data due to thesmall sample size. However, if we compile daily data over a continuousspan of ten years and still observe such a strong correlation, we wouldhave to believe in a causal relationship between investment intechnology and the number of suicides (for example, due to theinitiation of Frankenstein research).</p><p>Another situation is mutual causation, which cannot be representedusing a DAG. For instance, in an ecosystem, an increase in wolfpopulation leads to a decrease in sheep population, which in turnreduces the wolf population, leading to an increase in sheep population,which then causes an increase in the wolf population. The relationshipbetween wolf and sheep populations cannot be represented by a DAG. Thisarticle will not discuss such cases but will focus on relationships thatcan be represented using a DAG.</p><h2 id="foundation">Foundation</h2><p>Uppercase letters represent random variables, while lowercase lettersrepresent the values of these random variables. In the formulas, <span class="math inline">\(P(X)\)</span> denotes the probabilities for allvalues of <span class="math inline">\(X\)</span>, $P(X=x) or $<span class="math inline">\(P(x)\)</span> denotes the prbability of <span class="math inline">\(X=x\)</span>. <span class="math inline">\(P(X=x|Y=y)=P(x|y)\)</span> denotes the probabilityof <span class="math inline">\(X=x\)</span> when <span class="math inline">\(Y=y\)</span> holds. <span class="math inline">\(P(x_1,x_2,...x_n)\)</span> denotes the probabilityof <span class="math inline">\(X_1=x_1\wedge X_2=x_2,...\wedgeX_n=x_n\)</span>.</p><h3 id="conditional-independence">Conditional Independence</h3><p>In the case where the value of the random variable <span class="math inline">\(C\)</span> is determined (i.e., $ C = k $), ifrandom variables $ A $ and $ B $ are independent, then $ A $ and $ B $are conditionally independent given <span class="math inline">\(C =k\)</span>: <span class="math display">\[A \perp B | C = k \iff P(A | C = k) P(B | C = k) = P(AB | C = k)\]</span> If the above relationship holds for any value of $ C $, then $A $ and $ B $ are conditionally independent given $ C $, denoted as $ AB | C $. This is equivalent to: <span class="math display">\[P(B | C = k) = P(B | C = k, A) \\ P(A | C = k) = P(A | C = k, B)\]</span> Conditional independence of $ A $ and $ B $ given $ C $ isneither sufficient nor necessary for independence of $ A $ and $ B $.For example, let $ A $ be the event that the first coin toss results inheads, $ B $ be the event that the second coin toss results in heads,and $ C $ be the event that both tosses are heads. In this case, $ A $and $ B $ are independent, but $ P(A | C = 1) = P(B | C = 1) = P(AB | C= 1) = 1 $, hence $ A $ and $ B $ are not independent given $ C $. Onthe other hand, if $ A = B = C $, then we have $ P(A | C) P(B | C) =P(AB | C) = 1 $, but $ P(A) P(B) = P(A)^2 P(AB) = P(A) $.</p><h3 id="chain-rule">Chain Rule</h3><p>For random variables <span class="math inline">\(X_1,X_2...X_n\)</span>，when <span class="math inline">\(X_i=x_i\)</span>, the following equation holds<span class="math display">\[P(x_1,x_2,...x_n)=P(x_1)P(x_2|x_1)...P(x_n|x_1,x_2...x_{n-1})\]</span> It is infered directly from the definition of conditionalprobability.</p><h3 id="joint-probability-with-function">Joint Probability withFunction</h3><p>Let <span class="math inline">\(A\)</span>,<span class="math inline">\(B\)</span>,<span class="math inline">\(C\)</span>be random variables and <span class="math inline">\(C=f(A,B)\)</span>,then holds <span class="math display">\[P(C=c,A=a)=P(B=u_b,A=a).\]</span> where <span class="math inline">\(u_b\)</span> is the setsatisfying <span class="math inline">\(f(a,u_b)=c\)</span>.</p><h2 id="probability-models">Probability Models</h2><h3 id="naive-bayes">Naive Bayes</h3><p>In a classification task, we consider it as the probability of thetarget taking a certain value given the features, ultimately aiming toobtain <span class="math inline">\(P(y|x_1,x_2,...x_n)\)</span>. Usingthe relationship of conditional probabilities (Bayes' theorem): <span class="math display">\[P(y|x_1,x_2,...x_n)=\frac{P(x_1,x_2,...x_n|y)P(y)}{P(x_1,x_2,...x_n)}\]</span> Here, <span class="math inline">\(P(y)\)</span> can beobtained from the frequency of <span class="math inline">\(Y=y\)</span>.In classification tasks, the number of classes for the target value isgenerally much smaller than the number of samples, so this is feasible.However, <span class="math inline">\(P(x_1,x_2,...x_n|y)\)</span> and<span class="math inline">\(P(x_1,x_2,...x_n)\)</span> can not becalculated in this way because the combinations of features are toomany. For example, if each feature is binary, there are <span class="math inline">\(2^n\)</span> combinations, and we may not findsamples that fit these combinations. Thus, we need to simplify this byassuming the features are independent and that the features areindependent of the target. This simplifies the equation to: <span class="math display">\[P(y|x_1,x_2,...x_n)=\frac{P(x_1|y)P(x_2|y)...P(x_n|y)P(y)}{P(x_1)P(x_2)...P(x_n)}\]</span> In this way, <span class="math inline">\(P(x_k|y)\)</span> and<span class="math inline">\(P(x_k)\)</span> can both be obtained fromfrequencies.</p><p>Undoubtedly, this approach is quite wasteful; as the dataset featuresincrease, feature redundancy also increases, leading to worseperformance.</p><h3 id="bayesian-network">Bayesian Network</h3><p>The naive Bayes approach completely ignores the relationships betweenfeatures. In contrast, a Bayesian network does not make such extremesimplifications. It should be noted that a Bayesian network essentiallydescribes a graphical representation of the relationships among randomvariables. The direction of the arrows in the Bayesian network onlyindicates the order in which features are added; the connected variablesare related but do not necessarily imply causation. The manualalgorithmic process for constructing a Bayesian network is as follows.(Building a Bayesian network is an NP problem, so another approach is touse optimization algorithms for search.) Clearly, this method results ina Directed Acyclic Graph (DAG).</p><p>Input: Random variables <span class="math inline">\(V_1,V_2...V_n\)</span> Output: A directed acyclicgraph which describes the correlation among variables</p><ol type="1"><li>for <span class="math inline">\(i\)</span> in <span class="math inline">\(1,2...n\)</span> do</li><li>Add <span class="math inline">\(V_i\)</span> into the graph, if<span class="math inline">\(V_i\)</span> has correlation with any othernodes(which have a smaller order than <span class="math inline">\(V_i\)</span>) in the graph, add a directed edgebetween these two nodes with <span class="math inline">\(V_i\)</span> asthe end point. For example, if <span class="math inline">\(V_k(k&lt;i)\)</span> has a correlation with <span class="math inline">\(V_i\)</span>, then add a directed edge from <span class="math inline">\(V_k\)</span> to <span class="math inline">\(V_i\)</span></li><li>endfor</li><li>Compute the probability table for every point.</li></ol><h3 id="assumption-on-conditional-independence">Assumption onConditional Independence</h3><p>In a Bayesian network, the correlations are manually added, whichsimplifies the network structure. A Bayesian network can also beobtained using a group optimization algorithm, as it only considers thecorrelations between variables, which can be directly derived fromfrequencies.</p><p><img src="捕获.png" style="width:60.0%"></p><p>For example, the two diagrams on the left and right describe the samething (R: Rain; T: Traffic jam), namely the probability table on the farright. This probability table is directly obtained from the dataset.From a god's-eye view, the left diagram describes the correct causalrelationships. However, in practice, we can only derive the probabilitytable from the dataset, which allows us to determine only that there isa correlation between rain and traffic congestion. How to derivecausality will be discussed later; for now, let's clarify how to computethe probability table. Consider a Bayesian network consisting of <span class="math inline">\(n\)</span> variables. To compute <span class="math inline">\(P(v_1,v_2,...v_n)\)</span>, we use the chain rule:<span class="math display">\[P(v_n)=\prod _{i=1}^{n}P(v_i|v_1,...v_{i-1})\]</span></p><p>In the Bayesian network, if there is a relationship <span class="math inline">\(A\rightarrow B\rightarrow C\)</span>, we assumethat <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> are conditionally independent given<span class="math inline">\(B\)</span>, i.e., we assume: <span class="math display">\[v_i\perp \{v_1,...v_{i-1} \} \cap {\neg parent(v_i)}|parent(v_i)\]</span> then <span class="math display">\[P(v_i|v_1,...v_{i-1})=P(v_i|parent(v_{i}))\\\P(v_n)=\prod _{i=1}^{n}P(v_i|parent(v_{i}))\tag{1}\]</span> Generally, the number of parent nodes in a Bayesian network ismuch smaller than the total number of nodes, so calculating <span class="math inline">\(P(v_i|parent(v_{i}))\)</span> is feasible. Theconditional independence assumption is still a simplification butretains more information about feature relationships compared to naiveBayes.</p><h2 id="causal-model">Causal Model</h2><p>In a Bayesian network, the assumption of conditional independenceignores some relationships between features. In the relationship <span class="math inline">\(A\rightarrow B\rightarrow C\)</span>, <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> may not be independent given <span class="math inline">\(B\)</span>. In the manual construction algorithmsfor Bayesian networks, if a newly added node is correlated with nodesalready in the network, an edge is drawn, meaning <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> may be independent, but they are notnecessarily conditionally independent given <span class="math inline">\(B\)</span>. This was discussed in the firstsection. However, if we can construct a Bayesian network that adheres tothe assumption of conditional independence, this network can overcomethe limitations of the assumptions. This can be achieved by constructinga Bayesian network based on causality. In a causal DAG, the values ofcause nodes influence the values of effect nodes (though not necessarilydue to the existence of hidden variables).</p><h3 id="exogenous-variables">Exogenous Variables</h3><p>Some variables impact the data but are not recorded as features;these are known as hidden variables. Due to the presence of hiddenvariables, we cannot ensure that the value of a cause in the DAGcorresponds to a value of an effect. Instead, both the value of thecause and the value of the hidden variable jointly determine the valueof the effect, assuming the hidden variable is independent of theobserved variables.</p><h3 id="definition">Definition</h3><p>Causal relationships can be viewed as functions where causes serve asindependent variables and effects as dependent variables. Based on thisdefinition, the relationships between nodes in a causal DAG have thefollowing three basic types. (These relationships can also be applied innon-causal DAGs; in fact, they first appeared in non-causal DAGs, but incausal DAGs, the following can be strictly proven based on thedefinition, whereas in non-causal DAGs, they serve merely assimplifications without strict mathematical significance.)</p><ol type="1"><li>Chain: <span class="math inline">\(A\rightarrow B\rightarrowC\)</span></li><li>Common cause: <span class="math inline">\(A\leftarrow B\rightarrowC\)</span></li><li>Common effect: <span class="math inline">\(A\rightarrow B\leftarrowC\)</span></li></ol><p>In a chain relationship, according to the definition of causality,let <span class="math inline">\(A=f(U_A),B=g(A,U_B),C=h(B,U_C)\)</span>,where <span class="math inline">\(U_A,U_B,U_C\)</span> are sets oflatent variables.</p><ul><li>If <span class="math inline">\(P(B=b | A=a)=0\)</span>, then <span class="math inline">\(A=a\)</span> and <span class="math inline">\(B=b\)</span> are not independent. Otherwise, wehave</li></ul><p><span class="math display">\[\begin{aligned}P(B=b|A=a)&amp;=P(g(A,U_B)=b|A=a)=\frac{P(g(A,U_B)=b,A=a)}{P(A=a)}\\&amp;=\frac{P(A=a,U_B=u_b)}{P(A=a)}=P(U_B=u_b)\end{aligned}\]</span></p><p>​ where <span class="math inline">\(g(a,u_b)=b\)</span>, and <span class="math inline">\(u_b\)</span> is the set of all values of <span class="math inline">\(U_B\)</span> that satisfy this relationship.</p><ul><li><p>If <span class="math inline">\(P(B=b) = P(U_B=u_b)\)</span>, then$ A=a $ and $ B=b $ are independent, meaning that $ B=b $ holds onlywhen $ U_B=u_b $. Otherwise, $ P(B=b|A=a) P(B=b) $. In summary, $ A $and $ B $ are independent only when the value of $ B $ is completelydetermined by $ U_B $. Similarly, $ B $ and $ C $, as well as $ A $ and$ C $, may be dependent for some values and independent for others.However, $ A $ and $ C $ are conditionally independent given $ B $because:</p><ul><li>If $ P(B=b|A=a)=0 $, then $ P(A=a,B=b)=0 $, which implies $P(A=a|B=b)P(C=c|B=b)=P(A=a,C=c|B=b)=0 $, thus $ A C | B $. Similarly, if$ P(C=c|B=b)=0 $, then $ A C | B $. Otherwise, following a similarargument, we have <span class="math display">\[\begin{aligned}P(A=a,C=c|B=b)&amp;=\frac{P(A=a,B=b,C=c)}{P(B=b)}\\&amp;=\frac{P(A=a,B=b,U_C=u_c)}{P(B=b)}=\frac{P(A=a,U_B=u_b,U_C=u_c)}{P(B=b)}\\P(A=a|B=b)&amp;=\frac{P(A=a,U_B=u_b)}{P(B=b)}\\P(C=c|B=b)&amp;=P(U_C=u_c)\end{aligned}\]</span></li></ul></li></ul><p>Thus we have <span class="math display">\[P(A=a,C=c|B=b)=P(A=a|B=b)P(C=c|B=b)\]</span> In conclusion, $ A $ and $ C $ are conditionally independentgiven $ B $. Intuitively, when we know the value of $ B $, the value of$ C $ can be roughly determined, but we do not know which value of $ A $led to that value of $ B $.</p><p>It can be proven that in a common cause relationship, $ A $ and $ B$, $ C $ and $ B $, $ A $ and $ C $ may not be independent, but $ A $and $ C $ are conditionally independent given $ B $. This is alsointuitive because once $ B $ is given, the values of $ A $ and $ C $ aredetermined solely by latent variables.</p><p>In a common effect relationship, $ A $ and $ B $, $ C $ and $ B $ maynot be independent, but $ A $ and $ C $ are independent, and $ A $ and $C $ are conditionally independent given $ B $ and its child nodes.Consider the following scenario:</p><p>Tossing two coins, if at least one shows heads, a bell rings. Let $ X$: the first coin toss, $ Y $: the second coin toss, $ Z $: the ringingof the bell, conforming to the common effect relationship $ X Z Y $. Theprobability distribution of $ X, Y, Z $ is as follows:</p><p><img src="3.png"></p><p>From this, we can derive $ P(X=Head|Z=1)= $ and $P(X=Head|Y=Head,Z=1)= $. Knowing that $ Y $ is heads reduces theprobability of $ X $ being heads. Now suppose there is an unreliablebell-ringer who informs us that the bell rang, reporting 100% when itrings and having a 50% chance of reporting when it does not ring. Let $W $: the received report. The causal graph then becomes:</p><p><img src="4.png"></p><p>The probability distribution for $ X, Y, W $ is as follows:</p><p><img src="5.png"></p><p>From this, we find $ P(X=Head|W=1)= $, and <span class="math inline">\(P(X=Head|Y=Head,W=1)=0.5\)</span>. So <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are not conditionally independent given<span class="math inline">\(W\)</span>.</p><h3 id="directed-separation">Directed Separation</h3><p>Directed separation is used to determine whether two variables areindependent given other variables. It summarizes the three types of noderelationships mentioned above.</p><ul><li>If two variables $ X $ and $ Y $ are blocked by a set of variables $Z $, then $ X Y | Z $. The blocking includes the following two cases:<ol type="1"><li>A path $ p $ from $ X $ to $ Y $ contains a chain relationship $ A BC $ or a common cause relationship $ A B C $, and $ B $ is in $ Z$;</li><li>A path $ p $ from $ X $ to $ Y $ contains a common effectrelationship $ A B C $, and $ B $ and its child nodes are in $ Z $.</li></ol></li></ul><h3 id="intervening">Intervening</h3><p>“The difference between intervening on a variable and conditioning onthat variable should, hopefully, be obvious. When we intervene on avariable in a model, we fix its value. We change the system, and thevalues of other variables often change as a result. When we condition ona variable, we change nothing; we merely narrow our focus to the subsetof cases in which the variable takes the value we are interested in.What changes, then, is our perception about the world, not the worlditself.” ---Chapter 3.1 of <em>Casual Inference in Statistics</em></p><p>In the example of smoking and lung cancer, we cannot determine thecausality between smoking and lung cancer solely based on correlation.To assess causality, we can consider the following scenario: take agroup of individuals who do not smoke and force them to smoke, thenobserve the probability of developing lung cancer. Next, take a group ofindividuals without lung cancer and induce lung cancer in them, thenobserve the probability of smoking. Let $ X $: smoking, $ Y $: lungcancer. In the first case, the probability of lung cancer is higher thanthe baseline probability in the population, that is, $ P(Y=1|do(X=1))P(Y=1) $. In the second case, the probability of smoking remains equalto the population's smoking probability, $ P(X=1|do(Y=1))=P(X=1) $.These results indicate that smoking is a cause of lung cancer, whereaslung cancer is not a cause of smoking. It is important to note that thedo operator implies we are controlling the value of variable $ X $without altering the values of any latent variables. Otherwise, in acausal DAG, any latent variables that change must be represented asvariable nodes. (The original statement: "It is worth noting here thatwe are making a tacit assumption that the intervention has no 'sideeffects,' that is, that assigning the value $ x $ for the variable $ X $for an individual does not alter subsequent variables in a direct way."Here, "direct way" is somewhat vague.) We should note that $P(Y|do(X=1)) P(Y|X=1) $. When we enforce $ X=1 $, the parent nodes of $X $ no longer affect it; thus, all incoming edges of $ X $ disappear inthe causal DAG. Conversely, when $ X $ is not forcibly altered, itsparent nodes can influence both $ X $ and $ Y $. For example, let $ X $:increased sales at an ice cream shop, $ Y $: increased crime rate, $ Z$: hotter weather. Here, there is a causal relationship $ X Z Y $,represented in the following causal DAG:</p><p><img src="7.png"></p><p>If we take measures to set $ X=0 $, such as closing all ice creamshops, then $ Z $ can no longer influence $ X $, and the causal DAGchanges to:</p><p><img src="8.png"></p><p>In summary, intervening on a variable is equivalent to removing allincoming edges from it in the causal DAG, making it no longer a cause.Therefore, only when $ X $ is an orphan node can we have $ P(Y|do(X=1))= P(Y|X=1) $.</p><h3 id="intervention-and-observation">Intervention and Observation</h3><p>As long as we can obtain $ P(Y=y|do(X=x)) $, we can construct aperfect causal DAG. The example above provides a method for determiningcausality, but it is worth noting that in reality, we may not be able toconduct such experiments. To differentiate, we refer to this directcontrol of variables as intervention. Interventions allow us to directlyobtain $ P(Y=y|do(X=x)) $. As a secondary option, can we attempt toinfer causal relationships from correlational data? As mentionedearlier, for stable data, correlation can reflect causality. If we havestable data, we can use observation to assess the strength of causalrelationships and approximate $ P(Y=y|do(X=x)) $.</p><h3 id="causal-calculation">Causal Calculation</h3><h4 id="average-casual-effect">Average casual effect</h4><p>It is also worth noting that due to the presence of latent variables,we cannot derive definitive causal relationships from observationaldata; instead, we can only calculate the strength of causality betweenvariables. One straightforward idea is to control the values of $ X $and observe the differences in $ Y $ across different values of $ X $,as shown in the example below</p><p><img src="6.png"></p><p>To measure the strength of causality from $ X $ to $ Y $, considercalculating the difference in the probability of cure when using a drugversus not using it: <span class="math display">\[ACE=P(Y=1|do(X=1))-P(Y=1|do(X=0))\]</span> Next, we will attempt to calculate $ P(Y=y|do(X=x)) $.</p><h4 id="adjustment-formula">Adjustment Formula</h4><p>In the example of using drug, the causal DAG transfers to followingfigure when <span class="math inline">\(X\)</span> is fixed.</p><p><img src="9.png"></p><p>This is called manipulated model. The probabilities appearing in themanipulated model are denoted as <span class="math inline">\(P_m(*)\)</span> (while the probabilities in theoriginal causal DAG are denoted as $ P(*) $). Now, let's consider a moregeneral case of how to calculate $ P(Y=y|do(X=x)) $. Since $ X $ becomesan orphan node after control, we have $ P(Y=y|do(X=x)) = P_m(Y=y|X=x) $.Because $ X $ and $ Z $ are independent in the manipulated model, we canexpress: <span class="math display">\[\begin{aligned}P_m(Y=y|X=x)&amp;=\frac{P_m(Y=y,X=x)}{P_m(X=x)}=\sum_{z}\frac{P_m(Y=y,X=x,Z=z)}{P_m(X=x)}\\&amp;=\sum_{z}\frac{P_m(Y=y,X=x,Z=z)P_m(X=x,Z=z)}{P_m(X=x)P_m(X=x,Z=z)}\\&amp;=\sum_{z}P_m(Y=y|X=x,Z=z)P_m(Z=z|X=x)\\&amp;=\sum_{z}P_m(Y=y|X=x,Z=z)P_m(Z=z)\end{aligned}\]</span> At this point, the <span class="math inline">\(do\)</span>operator has been eliminated, and the mission of the manipulated modelis complete. In both the original causal DAG and the manipulated model,the causal relationships involving $ Y $ and the variables $ X $ and $ Z$ remain the same, i.e., $ Y = f(X,Z,U_Y) $. Thus, we have $P_m(Y=y|X=x,Z=z) = P(Y=y|X=x,Z=z) $ and $ Z $ is a cause in bothdiagrams, with $ Z = g(U_Z) $, therefore $ P_m(Z=z) = P(Z=z) $. In themanipulated model, only the functional relationship of $ X $ is altered;in the original causal DAG, $ X = h(Z,U_X) $, while in the manipulatedmodel, $ X = h_m(U_X) $. Thus, we have: <span class="math display">\[P(Y=y|do(X=x))=\sum_{z}P(Y=y|X=x,Z=z)P(Z=z)\]</span> The above equation is the correction formula for <span class="math inline">\(Z\)</span> when <span class="math inline">\(X\)</span> is controlled.</p><p>Now, consider the Simpson's paradox. Let <span class="math inline">\(X\)</span>: drug use, <span class="math inline">\(Y\)</span>: cure, and <span class="math inline">\(Z\)</span>: gender. The causal DAG is as shown inthe section on average causal effects. <span class="math display">\[\begin{aligned}P(Y=1|do(X=1))&amp;=P(Y=1|X=1,Z=men)P(Z=men)+P(Y=1|X=1,Z=women)P(Z=women)\\&amp;=0.93\times \frac{87+270}{700}+0.73\times\frac{263+80}{700}=0.832\\P(Y=1|do(X=0))&amp;=P(Y=1|X=0,Z=men)P(Z=men)+P(Y=1|X=0,Z=women)P(Z=women)\\&amp;=0.87\times \frac{87+270}{700}+0.69\times \frac{263+80}{700}=0.7818\end{aligned}\]</span> Thus, the average causal effect of <span class="math inline">\(X\)</span> on <span class="math inline">\(Y=1\)</span> is given by <span class="math display">\[ACE=P(Y=1|do(X=1))-P(Y=0|do(X=1))=0.0502\]</span></p><h4 id="causal-effect-rule">Causal Effect Rule</h4><p>The adjustment formula provides a method for eliminating the dooperator under a specific scenario. For a more general case, we can alsoleverage the manipulated model. In the manipulated model, two types ofnodes are independent of $ X $: one type is originally independent of $X $, and the other is the parent nodes $ PA(X) $ of $ X $.</p><p>For the first case, if $ Z $ is independent of $ X $, meaning thecausal relationship is $ X Y Z $, then the original DAG and themanipulated model are the same. We have: <span class="math display">\[P(Y|do(X=x)) = P_m(Y|X=x) = P(Y|X=x) = \sum_{z} P(Y|X=x,Z=z) P(Z=z).\]</span></p><p>This illustrates why the derivation below does not require theinclusion of all variables independent of $ X $ in the manipulatedmodel. When only the parent nodes of $ X $ are introduced, it remainsconsistent with the calculations in a Bayesian network. <span class="math display">\[\begin{aligned}P(Y=y|do(X=x))&amp;=\frac{P_m(Y=y,X=x)}{P_m(X=x)}\\&amp;=\sum_{z}\frac{P_m(Y=y,X=x,PA(X)=z)}{P_m(X=x)}\\&amp;=\sum_{z}\frac{P_m(Y=y,X=x,PA(X)=z)P_m(X=x,PA(X)=z)}{P_m(X=x)P_m(X=x,PA(X)=z)}\\&amp;=\sum_{z}P_m(Y=y|X=x,PA(X)=z)P_m(PA(X)=z|X=x)\\&amp;=\sum_z P(Y=y|X=x,PA(X)=z)P(PA(X)=z)\\&amp;=\sum_z \frac{P(X=x,Y=y,PA(X)=z)}{P(X=x|PA(X)=z)}\end{aligned}\tag{2}\]</span></p><h4 id="backdoor-criterion">Backdoor Criterion</h4><p>Observing the derivation process of the above formula, the key pointis that $ P_m(Y=y|X=x,PA(X)=z) = P(Y=y|X=x,PA(X)=z) $ and $P_m(PA(X)=z|X=x) = P_m(PA(X)=z) = P(PA(X)=z) $.</p><p>The first equality holds under the condition that fixing $ X $ and $PA(X) $ yields the same probability distribution for $ Y $ in both theoriginal DAG and the manipulated model. Since the manipulated model onlyeliminates the incoming edges of $ X $, the value of any confoundingnode that exists between $ X $ and $ Y $ will be fixed, meaning that thevalue of $ Y $ will only be influenced by $ X $ and nodes independent of$ X $.</p><p>For instance, consider the following causal relationship:</p><p><img src="10.png" style="zoom:50%;"></p><p>We have: <span class="math display">\[\begin{aligned}P(Y=y|X=x,Z=z)&amp;=\frac{P(Y=y,X=x,Z=z)}{P(X=x,Z=z)}\\&amp;=\frac{P(f(X,Z,W,U_Y)=y,X=x,Z=z)}{P(X=x,Z=z)}\\&amp;=\frac{P(W=u_w,U_Y=u_y,X=x,Z=z)}{P(X=x,Z=z)}\end{aligned}\tag{3}\]</span> Here, $ u_w, u_y $ are all values satisfying $ f(x,z,W,U_Y)=y$. Since $ W $ is not independent of $ X $, we cannot obtain $P(W=u_w,U_Y=u_y,X=x,Z=z) = P(W=u_w)P(U_Y=u_y)P(X=x,Z=z) $. However,</p><p><span class="math display">\[\begin{aligned}P_m(Y=y|X=x,Z=z)&amp;=\frac{P_m(X=x,Z=z,W=u_w,U_Y=u_y)}{P_m(X=x,Z=z)}\\&amp;=\frac{P_m(X=x)P_m(Z=z)P_m(W=u_w)P_m(U_Y=u_y)}{P_m(X=x)P_m(Z=z)}\\&amp;=P_m(W=u_w)P_m(U_Y=u_y)\end{aligned}\tag{4}\]</span> By observing the differences between equations (3) and (4), wesee that to eliminate the denominator in (3), both $ W $, $ X $, and $ Z$ must be eliminated simultaneously, leading to: <span class="math display">\[\begin{aligned}P(Y=y|X=x,Z=z,W=w)&amp;=\frac{P(W=w,U_Y=u_y,X=x,Z=z)}{P(X=x,Z=z,W=w)}\\&amp;=P(U_Y=u_y)\end{aligned}\]</span> On the other hand <span class="math display">\[\begin{aligned}P_m(Y=y|X=x,Z=z,W=w)&amp;=\frac{P_m(X=x,Z=z,W=w,U_Y=u_y)}{P_m(X=x,Z=z,W=w)}\\&amp;=P_m(U_Y=u_y)\\&amp;=P(Y=y|X=x,Z=z,W=w)\end{aligned}\]</span> Therefore, only by fixing the values of all confounding nodescan we obtain $ P_m(Y=y|X=x,Z=z,W=w) = P(Y=y|X=x,Z=z,W=w) $.</p><p>The condition for the second equality to hold is that $ PA(X) $ and $X $ are independent in the manipulated model. Thus, any set of nodesthat is independent of $ X $ in the manipulated model can replace $PA(X) $ in the derivation above. Therefore, when the parent nodes of $ X$ are difficult to identify, we can use these two conditions to findalternative nodes to compute with, yielding the same results. This isreferred to as the backdoor criterion, as expressed in equation (5):</p><p><span class="math display">\[P(Y=y|do(X=x))=\sum_zP(Y=y|X=x,W=w)P(W=w)\tag{5}\]</span> The set of nodes $ W $ must satisfy the following twoconditions:</p><ol type="1"><li>$ W $ does not include any descendant nodes of $ X $;</li><li>$ W $ blocks all paths pointing from $ X $ to $ Y $.</li></ol><p>These two conditions are equivalent to the conclusions derivedabove:</p><ol type="1"><li>$ W $ includes all confounding nodes;</li><li>In the manipulated model, $ X $ is independent of the nodes in $ W$.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>Causal Inference</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Best Clips in The Book of Why</title>
    <link href="/2023/08/21/TBOW/"/>
    <url>/2023/08/21/TBOW/</url>
    
    <content type="html"><![CDATA[<p>​ I was probably six or seven years old when I first read the story ofAdam and Eve in the Garden of Eden. My classmates and I were not at allsurprised by God’s capricious demands, forbidding them to eat from theTree of Knowledge. Deities have their reasons, we thought. What we weremore intrigued by was the idea that as soon as they ate from the Tree ofKnowledge, Adam and Eve became conscious, like us, of their nakedness.As teenagers, our interest shifted slowly to the more philosophicalaspects of the story. (Israeli students read Genesis several times ayear.) Of primary concern to us was the notion that the emergence ofhuman knowledge was not a joyful process but a painful one, accompaniedby disobedience, guilt, and punishment. Was it worth giving up thecarefree life of Eden? some asked. Were the agricultural and scientificrevolutions that followed worth the economic hardships, wars, and socialinjustices that modern life entails?</p><p>​ Don’t get me wrong: we were no creationists; even our teachers wereDarwinists at heart. We knew, however, that the author who choreographedthe story of Genesis struggled to answer the most pressing philosophicalquestions of his time. We likewise suspected that this story bore thecultural footprints of the actual process by which Homo sapiens gaineddominion over our planet. What, then, was the sequence of steps in thisspeedy, super-evolutionary process?</p><p>​ My interest in these questions waned in my early career as aprofessor of engineering but was reignited suddenly in the 1990s, when,while writing my book Causality, I confronted the Ladder of Causation.As I reread Genesis for the hundredth time, I noticed a nuance that hadsomehow eluded my attention for all those years. When God finds Adamhiding in the garden, he asks, “Have you eaten from the tree which Iforbade you?” And Adam answers, “The woman you gave me for a companion,she gave me fruit from the tree and I ate.” “What is this you havedone?” God asks Eve. She replies, “The serpent deceived me, and Iate.”</p><p>​ As we know, this blame game did not work very well on the Almighty,who banished both of them from the garden. But here is the point I hadmissed before: God asked “what,” and they answered “why.” God asked forthe facts, and they replied with explanations. Moreover, both werethoroughly convinced that naming causes would somehow paint theiractions in a different light. Where did they get this idea?</p><p>​ For me, these nuances carried three profound implications. First,very early in our evolution, we humans realized that the world is notmade up only of dry facts (what we might call data today); rather, thesefacts are glued together by an intricate web of cause-effectrelationships. Second, causal explanations, not dry facts, make up thebulk of our knowledge, and should be the cornerstone of machineintelligence. Finally, our transition from processors of data to makersof explanations was not gradual; it was a leap that required an externalpush from an uncommon fruit. This matched perfectly with what I hadobserved theoretically in the Ladder of Causation: No machine can deriveexplanations from raw data. It needs a push.</p><p>​ If we seek confirmation of these messages from evolutionary science,we won’t find the Tree of Knowledge, of course, but we still see a majorunexplained transition. We understand now that humans evolved fromapelike ancestors over a period of 5 million to 6 million years and thatsuch gradual evolutionary processes are not uncommon to life on earth.But in roughly the last 50,000 years, something unique happened, whichsome call the Cognitive Revolution and others (with a touch of irony)call the Great Leap Forward. Humans acquired the ability to modify theirenvironment and their own abilities at a dramatically faster rate. Forexample, over millions of years, eagles and owls have evolved trulyamazing eyesight—yet they’ve never devised eyeglasses, microscopes,telescopes, or night-vision goggles. Humans have produced these miraclesin a matter of centuries. I call this phenomenon the “super-evolutionaryspeedup.” Some readers might object to my comparing apples and oranges,evolution to engineering, but that is exactly my point.</p><p>​ Evolution has endowed us with the ability to engineer our lives, agift she has not bestowed on eagles and owls, and the question, again,is “Why?” What computational facility did humans suddenly acquire thateagles did not? Many theories have been proposed, but one is especiallypertinent to the idea of causation. In his book Sapiens, historian YuvalHarari posits that our ancestors’ capacity to imagine nonexistent thingswas the key to everything, for it allowed them to communicate better.Before this change, they could only trust people from their immediatefamily or tribe. Afterward their trust extended to larger communities,bound by common fantasies (for example, belief in invisible yetimaginable deities, in the afterlife, and in the divinity of the leader)and expectations. Whether or not you agree with Harari’s theory, theconnection between imagining and causal relations is almostself-evident. It is useless to ask for the causes of things unless youcan imagine their consequences. Conversely, you cannot claim that Evecaused you to eat from the tree unless you can imagine a world in which,counter to facts, she did not hand you the apple.</p><p>​ Back to our Homo sapiens ancestors: their newly acquired causalimagination enabled them to do many things more efficiently through atricky process we call “planning.” Imagine a tribe preparing for amammoth hunt. What would it take for them to succeed? My mammoth-huntingskills are rusty, I must admit, but as a student of thinking machines, Ihave learned one thing: a thinking entity (computer, caveman, orprofessor) can only accomplish a task of such magnitude by planningthings in advance—by deciding how many hunters to recruit; by gauging,given wind conditions, the direction from which to approach the mammoth;in short, by imagining and comparing the consequences of several huntingstrategies. To do this, the thinking entity must possess, consult, andmanipulate a mental model of its reality. Note that there are multiplecauses for the chances of success and that none of them aredeterministic. That is, we cannot be sure that having more hunters willenable success or that rain will prevent it, but these factors do changethe probability of success.</p><p>​ The mental model is the arena where imagination takes place. Itenables us to experiment with different scenarios by making localalterations to the model. Somewhere in our hunters’ mental model was asubroutine that evaluated the effect of the number of hunters. When theyconsidered adding more, they didn’t have to evaluate every other factorfrom scratch. They could make a local change to the model, replacing“Hunters = 8” with “Hunters = 9,” and reevaluate the probability ofsuccess. This modularity is a key feature of causal models. I don’t meanto imply, of course, that early humans actually drew a pictorial modellike this one. But when we seek to emulate human thought on a computer,or indeed when we try to solve unfamiliar scientific problems, drawingan explicit dots-and-arrows picture is extremely useful. These causaldiagrams are the computational core of the “causal inference engine”.</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>Causal Inference</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Why Does Evolutionary Optimization Work</title>
    <link href="/2023/05/01/Why%20Does%20Evolutionary%20Optimization%20Work/"/>
    <url>/2023/05/01/Why%20Does%20Evolutionary%20Optimization%20Work/</url>
    
    <content type="html"><![CDATA[<p>​ People love to derive theories from reality. It is surprising thatthey can get so hooked on it that sometimes the theory ends up goingagainst reality. The more surprising part is it actually works.Evolutionary optimization methods are pretty much playing that game.</p><span id="more"></span><p>​ Evolutionary optimization methods come from the simulation of nature-- but a rather clumsy one. Although some intuitive explanations areoften provided in the papers, we are still not sure why it works on amathematical level, why they find optimal solutions, and why they areeasily stuck into local optima.</p><p>​ There exists a dilemma: if an evolutionary optimization method hasmore opportunities to search for a wider range in feature space, it hasmore freedom to escape local optima. However, they struggle to utilizethe discovered optima and consequently converge more slowly. On theother hand, a method which tries to achieve faster convergence mustsacrifice the ability to explore new feature space. This phenomenon hasbeen demonstrated in many past experimental papers. The following is anexample of comparison on an interesting evolutionary optimization methodcalled Snake Optimizer. I provide an improved version which has morefreedom compared with the original version. The sample code can be found<a href="https://github.com/haodi333/Improved-Snake-Optimizer/tree/main">here</a>.</p><p>​ The results of both versions on three testing functions are shown asfollows.</p><p><img src="sphere.png"></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">----</span><span class="hljs-comment">SO</span><span class="hljs-literal">----</span><br><span class="hljs-comment">Best fitness： 6</span><span class="hljs-string">.</span><span class="hljs-comment">91954186361586e</span><span class="hljs-literal">-</span><span class="hljs-comment">15</span><br><span class="hljs-literal">----</span><span class="hljs-comment">ISO</span><span class="hljs-literal">----</span><br><span class="hljs-comment">Best fitness： 3</span><span class="hljs-string">.</span><span class="hljs-comment">314727870088089e</span><span class="hljs-literal">-</span><span class="hljs-comment">17</span><br></code></pre></td></tr></table></figure><p><img src="ackley.png"></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">----</span><span class="hljs-comment">SO</span><span class="hljs-literal">----</span><br><span class="hljs-comment">Best fitness： 5</span><span class="hljs-string">.</span><span class="hljs-comment">035539037828684</span><br><span class="hljs-literal">----</span><span class="hljs-comment">ISO</span><span class="hljs-literal">----</span><br><span class="hljs-comment">Best fitness： 0</span><span class="hljs-string">.</span><span class="hljs-comment">02119983870372666</span><br></code></pre></td></tr></table></figure><p><img src="generalized.png"></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">----</span><span class="hljs-comment">SO</span><span class="hljs-literal">----</span><br><span class="hljs-comment">Best fitness： 2</span><span class="hljs-string">.</span><span class="hljs-comment">307579084774835e</span><span class="hljs-literal">-</span><span class="hljs-comment">13</span><br><span class="hljs-literal">----</span><span class="hljs-comment">ISO</span><span class="hljs-literal">----</span><br><span class="hljs-comment">Best fitness： 1</span><span class="hljs-string">.</span><span class="hljs-comment">8959354360877344e</span><span class="hljs-literal">-</span><span class="hljs-comment">18</span><br></code></pre></td></tr></table></figure><p>​ See what? The improved version has a slower convergence rate, yet itultimately achieves better results than the original version. Moredetails about how I changed the procedure of the algorithm can be foundin the <a href="https://d.wanfangdata.com.cn/periodical/wjfz202405017">paper</a>.(Unfortunately, it is written in Chinese if you can't read it).</p><p>​ Frankly speaking it took me two months to find this improvement, andit took me much time to understand the reasons behind it to date. Maybewe can't achieve both a fast convergence rate and a wide explorationrange; can this dilemma be extended to all black-box optimizationproblems? From this perspective, there may not be a "better"evolutionary optimization method, and all evolutionary optimizationmethods are just balance points on this scale.</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>Optimization</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/2023/01/09/Java/"/>
    <url>/2023/01/09/Java/</url>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="权限修饰符">权限修饰符</h2><ul><li>private声明的类只能在本类中调用；</li><li>不写权限修饰符，本包中其他类可以调用；</li><li>protected声明的类，不同包下的子类可以调用；</li><li>public声明的类不同包的无关子类可以调用；</li></ul><p>​ 子类重写父类的方法，重写的方法权限不能低于父类方法。</p><h2 id="静态变量static">静态变量static</h2><ul><li>被static修饰的成员变量叫做静态变量，它被该类中所有对象共享，对所有对象，它都是同一个值。相当于指针指到了同一块区域。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> package1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span><br>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String teacher;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTeacher</span><span class="hljs-params">(String teacher)</span><br>    &#123;<br>        student.teacher=teacher;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;, &quot;</span>+age+<span class="hljs-string">&quot;, &quot;</span>+teacher);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>teacher</code>声明为static变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> package1.student;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student_test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">10</span>);<br>    s1.setTeacher(<span class="hljs-string">&quot;Mike&quot;</span>);<br>    s1.show(); <br><br>    student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>(<span class="hljs-string">&quot;Wang&quot;</span>, <span class="hljs-number">10</span>);<br>    s2.show();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*输出结果</span><br><span class="hljs-comment">Tom, 10, Mike</span><br><span class="hljs-comment">Wang, 10, Mike</span><br></code></pre></td></tr></table></figure><p>只在s1中对teacher赋值，下面的s2同样有teacher这个变量。一个方法一旦被声明为static，它就可以直接由类名访问。例如<code>setTeacher</code>方法用static修饰：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setTeacher</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> teacher</span>)<br>&#123;<br>    student.<span class="hljs-property">teacher</span>=teacher;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接调用<code>student.setTeacher</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> package1.student;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student_test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    student.setTeacher(<span class="hljs-string">&quot;Mike&quot;</span>);<br>    student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">10</span>);<br>    s1.show(); <br><br>    student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>(<span class="hljs-string">&quot;Wang&quot;</span>, <span class="hljs-number">10</span>);<br>    s2.show();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*输出结果</span><br><span class="hljs-comment">Tom, 10, Mike</span><br><span class="hljs-comment">Wang, 10, Mike</span><br></code></pre></td></tr></table></figure><h2 id="继承">继承</h2><p>​Java不支持多继承，一个类只能继承一个直接父类。Java所有的类都直接或间接继承Object类。</p><h2 id="重写和重载">重写和重载</h2><p>​ 重写是子类对父类的允许访问的方法的实现过程进行重新编写,返回类型和形参都不能改变。也就是仅改变了方法内容。重写方法的访问权限不能比父类中被重写的方法的访问权限更低。</p><p>​重载是在一个类里定义多个类名相同功能不同的方法，为了区分它们，必须让形参不同。访问权限，返回类型随意。</p><h2 id="接口">接口</h2><p>​接口是类的蓝图，包括static的属性和abstract的方法。接口是实现抽象类的机制。常用于多继承，部分子类共有的父类的方法可以声明为一个接口，接口中定义了这种方法的规范。Java编译器会在接口方法前面自动加publicabstract修饰，属性前面加public static final方法。</p><p>​实现接口的类中的方法，修饰符为public，因为接口的方法为public修饰，实例化的方法权限不低于public，所以为public修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">printable</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">printable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​接口可以继承，格式为<code>interface 接口名 extends 接口名1，接口名2...&#123; &#125;</code></p><h2 id="抽象类">抽象类</h2><ul><li>抽象类是含有未实现方法的类</li><li>抽象类不能实例化。因为未实现方法无法调用</li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>可以有构造方法</li><li>抽象类的子类要么重写抽象类中的所有抽象方法，要么是抽象类</li></ul><h2 id="stream流">Stream流</h2><p>​ stream流用于处理数据，</p><h2 id="多线程">多线程</h2><p>​有两种方式创造新的线程，声明为Thread的子类或声明一个实现Runnable接口的类。</p><p>线程的生命周期有5个状态：</p><ul><li><p>新建状态:</p><p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong>类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序<strong>start()</strong> 这个线程。</p></li><li><p>就绪状态:</p><p>当线程对象调用了<strong>start()</strong>方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p></li><li><p>运行状态:</p><p>如果就绪状态的线程获取 CPU 资源，就可以执行<strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>阻塞状态:</p><p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait()方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join()等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul></li><li><p>死亡状态:</p><p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p><p><img src="image/image1.png" align="middle" width="60%"></p><h3 id="线程的优先级">线程的优先级</h3><p>​ 每一个 Java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java线程的优先级是一个整数，其取值范围是1-10.</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<span class="hljs-comment">//Runnable里定义了Thread类，class RunnableDemo extends Thread</span><br>    <span class="hljs-keyword">private</span> Thread t;<span class="hljs-comment">//t属于线程类</span><br>    <span class="hljs-keyword">private</span> String threadName;<br>    <br>    RunnableDemo( String name) &#123;<br>       threadName = name;<br>       System.out.println(<span class="hljs-string">&quot;Creating &quot;</span> +  threadName );<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;Running &quot;</span> +  threadName );<br>       <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>             System.out.println(<span class="hljs-string">&quot;Thread: &quot;</span> + threadName + <span class="hljs-string">&quot;, &quot;</span> + i);<br>             <span class="hljs-comment">// 让线程睡眠一会</span><br>             Thread.sleep(<span class="hljs-number">50</span>);<br>          &#125;<br>       &#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> +  threadName + <span class="hljs-string">&quot; interrupted.&quot;</span>);<br>       &#125;<br>       System.out.println(<span class="hljs-string">&quot;Thread &quot;</span> +  threadName + <span class="hljs-string">&quot; exiting.&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span> <span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;Starting &quot;</span> +  threadName );<br>       <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>          t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (<span class="hljs-built_in">this</span>, threadName);<br>          t.start ();<span class="hljs-comment">//开启一个线程</span><br>       &#125;<br>    &#125;<br> &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>       <span class="hljs-type">RunnableDemo</span> <span class="hljs-variable">R1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableDemo</span>( <span class="hljs-string">&quot;Thread-1&quot;</span>);<br>       R1.start();<br>       <br>       <span class="hljs-type">RunnableDemo</span> <span class="hljs-variable">R2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableDemo</span>( <span class="hljs-string">&quot;Thread-2&quot;</span>);<br>       R2.start();<br>    &#125;   <br> &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Programming</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论</title>
    <link href="/2022/04/27/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    <url>/2022/04/27/%E7%9F%A9%E9%98%B5%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="矩阵导数">矩阵导数</h1><p>​矩阵导数即对矩阵的多个元素求导，作为一种简便的计算方式。在下面的计算过程中，标量，向量均作为特殊的矩阵，如无指出是标量或向量，矩阵的含义均包括了是标量，向量，矩阵的情况。在矩阵导数中，因变量矩阵的每个元素与自变量矩阵中的每个元素均存在映射。</p><p>​在可能混淆的地方，小写字母为标量，加粗或希腊字母为向量，大写字母为矩阵。在函数中用<span class="math inline">\(y,Y\)</span>做自变量，<span class="math inline">\(f\)</span>表示函数关系，<span class="math inline">\(dy,dY\)</span>表示全微分，<span class="math inline">\(\frac{\partial f}{\partial x_i}\)</span>表示<span class="math inline">\(y\)</span>对<span class="math inline">\(x_i\)</span>的偏导数。将矩阵每个元素视为自变量，要求因变量（标量或矩阵）对该矩阵每个元素的导数构成的矩阵。在不引起混淆的情况下，使用<span class="math inline">\(f&#39;(X)\)</span>作为<span class="math inline">\(\frac{\partial f(X)}{\partialX}\)</span>的简写形式。</p><p>​ 在形如<span class="math inline">\(Y=f(X_{m\timesn})\)</span>的矩阵运算中，自变量矩阵<span class="math inline">\(X\)</span>每个元素与因变量矩阵<span class="math inline">\(Y\)</span>存在映射，因此<span class="math inline">\(Y\)</span>为1×1矩阵(或标量)时，<span class="math inline">\(\frac{\partial f}{\partial X}\)</span>应有<span class="math inline">\(m\times n\)</span>个元素，若<span class="math inline">\(Y\)</span>为<span class="math inline">\(p\timesq\)</span>矩阵时，<span class="math inline">\(\frac{\partial f}{\partialX}\)</span>应有<span class="math inline">\(p\times q\times m\timesn\)</span>个元素。然而，这可能有多种表示方式。本文采用向量化方法，详见下。</p><h2 id="计算技巧">计算技巧</h2><h3 id="hadamard积">Hadamard积</h3><p>对同形矩阵<span class="math inline">\(A,B\in R^{m\timesn}\)</span>，表现为按元素乘: <span class="math display">\[[A\odot B]_{ij}=a_{ij}b_{ij}\]</span> 在numpy中可以直接将两个同形矩阵相乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>A = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])<br>B = np.array([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br>Hadamard_A_B = A*B<br></code></pre></td></tr></table></figure><h3 id="kronecker积">Kronecker积</h3><p>对于<span class="math inline">\(A\in R^{m\times n},B\in R^{p\timesq}\)</span>，B对A中每个元素<span class="math inline">\(a_{ij}\)</span>进行数乘并将结果取代<span class="math inline">\(a_{ij}\)</span>位置: <span class="math display">\[[A\otimes B]_{ij}=a_{ij}B\]</span> numpy实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>A = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])<br>B = np.array([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br>Kronecker_A_B = np.kron(A, B)<br></code></pre></td></tr></table></figure><h3 id="向量化">向量化</h3><p><span class="math inline">\(vec(X_{m\times n})\)</span>表示将<span class="math inline">\(X\)</span>逐列转换为列向量： <span class="math display">\[[vec(X)]_{i}=X_{[\frac{i}{m}],i-m[\frac{i}{m}]+1}\]</span> 其中<span class="math inline">\([a]\)</span>表示对有理数<span class="math inline">\(a\)</span>向下取整。在numpy中使用reshape()即可。</p><h3 id="变量矩阵等价的唯一性">变量矩阵等价的唯一性</h3><p>​ 对于变量矩阵<span class="math inline">\(X_{mn},Y_{nq},Z_{nq}\)</span>，若存在<span class="math inline">\(X=X&#39;\)</span>使得<span class="math inline">\(X\)</span>列满秩，且有<span class="math inline">\(XY=XZ\)</span>，则<span class="math inline">\(Y=Z\)</span>。关于这个结论，暂未查找到资料。然而这是十分重要的。所以，在此给出一个证明。</p><p>​ For all column vectors <span class="math inline">\(X_{.1},X_{.2},...X_{.n}\)</span> in <span class="math inline">\(X\)</span>： <span class="math display">\[k_1X_{.1}+k_2X_{.2}+...+k_nX_{.n}=0 \quad \Rightarrowk_1,k_2,...k_n=0\tag{1}\]</span> ​ Suppose <span class="math inline">\(Y\neq Z,XY=XZ\)</span>,then <span class="math display">\[X(Y-Z)=0\]</span> ​ Let <span class="math inline">\(W=Y-Z\)</span>, then <span class="math inline">\(W\neq 0\)</span>, for all column vectors <span class="math inline">\(W_{.1},W_{.2}...W_{.q}\)</span> in <span class="math inline">\(W\)</span>: <span class="math display">\[\exists {i} \quad s.t.W_{.i}\neq0\]</span> Consider the multiplication of <span class="math inline">\(X\)</span> and <span class="math inline">\(W_{.i}\)</span>: <span class="math display">\[XW_{.i}=(X_{.1},X_{.2},...X_{.n})W_{.i}=X_{.1}W_{1i}+X_{.2}W_{2i}+...X_{.n}W_{ni}=0\]</span> ​这与(1)矛盾。对于可行满秩的变量矩阵，同理，改为左乘即可。在下面计算矩阵导数时将用到这个结论。</p><h2 id="多元函数导数">多元函数导数</h2><p>​ 对于多元函数<span class="math display">\[y=f(x_1,x_2,...,x_n)\]</span>，其微分<span class="math inline">\(dy\)</span>为： <span class="math display">\[dy=\sum_{i=1}^{n}\frac{\partial f}{\partial x_i}dx_i\]</span> 以向量形式表示，令 <span class="math display">\[d\mathbf{x}=(dx_1,dx_2,...,dx_n)\\\frac{\partial f}{\partial \mathbf{x}}=(\frac{\partial f}{\partialx_1},\frac{\partial f}{\partial x_2},...,\frac{\partial f}{\partialx_n})\]</span> <span class="math inline">\(\frac{\partial f}{\partial\mathbf{x} }\)</span>即在点<span class="math inline">\((x_1,x_2,...,x_n)\)</span>的梯度。则将<span class="math inline">\(dy\)</span>表示为 <span class="math display">\[dy=\frac{\partial f}{\partial \mathbf{x}}^Td\mathbf{x}\]</span></p><h2 id="标量对矩阵导数">标量对矩阵导数</h2><p>​ 对于<span class="math inline">\(y=f(X_{m\times n})\)</span>，<span class="math inline">\(f\)</span>将矩阵<span class="math inline">\(X\)</span>映射为标量，<span class="math inline">\(y\)</span>与<span class="math inline">\(X\)</span>的全体元素存在映射关系。仿照多元函数，微分<span class="math inline">\(dy\)</span>为： <span class="math display">\[dy=\sum_{i=1}^{m}{\sum_{j=1}^{n}{\frac{\partial f}{\partial X_{ij} } }}dX_{ij}\]</span> 其中 <span class="math display">\[dX=\left[\begin{matrix}dX_{11} &amp; \cdots &amp; dX_{1n}\\\vdots &amp; \ddots &amp;  \\dX_{m1} &amp;  &amp; dX_{mn}\end{matrix}\right]\]</span> <span class="math inline">\(dX\)</span>是与<span class="math inline">\(X\)</span>同形的矩阵，<span class="math inline">\(dX_{ij}\)</span>表示<span class="math inline">\(X_{ij}\)</span>的微分。在<span class="math inline">\(X\)</span>中，每个元素都是一个自变量。令 <span class="math display">\[\frac{\partial f}{\partial X}=\left[\begin{matrix}\frac{\partial{f} }{dX_{11} } &amp; \cdots &amp; \frac{\partial{f}}{dX_{1n} }\\\vdots &amp; \ddots &amp;  \\\frac{\partial{f} }{dX_{m1} } &amp;  &amp; \frac{\partial{f} }{dX_{mn} }\end{matrix}\right]\]</span> 于是 <span class="math display">\[dy=tr(\frac{\partial f}{\partial X}^TdX)\tag{*}\]</span> <span class="math inline">\(tr(X)\)</span> is the trace of<span class="math inline">\(X\)</span>，which stands for the summary ofthe diagonal elements of <span class="math inline">\(X\)</span>. Noticethat the <span class="math inline">\(X\)</span> here is a square.</p><h3 id="链式法则">链式法则</h3><ol type="1"><li>若<span class="math inline">\(y=f(Y),Y=AXB+C\)</span>，则根据(*)式：</li></ol><p><span class="math display">\[dy=tr(\frac{\partial f}{\partial Y}^TdY)=tr(\frac{\partial f}{\partialX}^TdX)\]</span></p><p>因为 <span class="math display">\[dY=AdXB\]</span> 则根据性质10： <span class="math display">\[tr(\frac{\partial f}{\partial Y}^TdY)=tr(\frac{\partial f}{\partialY}^TAdXB)=tr(B\frac{\partial f}{\partial Y}^TAdX)=tr(\frac{\partialf}{\partial X}^TdX)\]</span> 于是 <span class="math display">\[\frac{\partial f}{\partial X}^T=B\frac{\partial f}{\partial Y}^TA\\\frac{\partial f}{\partial X}=A^T\frac{\partial f}{\partial Y}B^T\]</span></p><ol start="2" type="1"><li>若<span class="math inline">\(y=f(Y),Y=\sigma(X)\)</span>，其中<span class="math inline">\(\sigma(X)\)</span>为逐元素的函数，因为</li></ol><p><span class="math display">\[dY=\frac{\partial \sigma}{\partial X_{} }\odot dX\]</span></p><p>则根据性质11： <span class="math display">\[tr(\frac{\partial f}{\partial Y}^TdY)=tr(\frac{\partial f}{\partialY}^T(\frac{\partial \sigma}{\partial X_{} }\odot dX))=tr((\frac{\partialf}{\partial Y}^T\odot \frac{\partial \sigma}{\partial X}^T)dX))=tr(\frac{\partial f}{\partial X}^TdX)\]</span> 于是 <span class="math display">\[\frac{\partial f}{\partial X}=\frac{\partial f}{\partial Y}\odot\frac{\partial \sigma}{\partial X }\]</span></p><h2 id="性质">性质</h2><ol type="1"><li><span class="math inline">\(d(X \pm Y)=d(X)\pm d(Y)\)</span></li><li><span class="math inline">\(d(X_{m \times p}Y_{p\timesn})=(dX)Y+X(dY)\)</span></li></ol><p>​ 证明： <span class="math display">\[d(XY)_{ij}=d(\sum_{i=1}^p{X_{ip}Y_{pj}})=\sum_{i=1}^p(dX_{ip}Y_{pj})+\sum_{i=1}^p(X_{ip}dY_{pj})=(dX)_{i.}Y_{.j}+(dX)_{.i}Y_{j.}\]</span></p><ol start="3" type="1"><li><p><span class="math inline">\(d(X^T)=(dX)^T\)</span></p></li><li><p><span class="math inline">\((dX)^{-1}=-X^{-1}dXX^{-1}\)</span></p></li></ol><p>​ 证明： <span class="math display">\[XX^{-1}=I\\Xd(X^{-1})+(dX)X^{-1}=d(XX^{-1})=d(I)=0\\(dX)^{-1}=-X^{-1}dXX^{-1}\]</span></p><ol start="5" type="1"><li><span class="math inline">\(d(\sigma(X))=\frac{\partial\sigma}{\partial X}\odot dX\)</span></li></ol><p>证明： <span class="math display">\[\begin{aligned}d(\sigma(X))=\left[\begin{matrix}\frac{\partial \sigma}{\partial X_{11}}dX_{11} &amp; \cdots &amp;\frac{\partial \sigma}{\partial X_{1n}}dX_{1n}\\\vdots &amp; \ddots &amp;  \\\frac{\partial \sigma}{\partial X_{m1}}dX_{m1} &amp;  &amp;\frac{\partial \sigma}{\partial X_{mn} }dX_{mn}\end{matrix}\right]= \left[\begin{matrix}\frac{\partial \sigma}{\partial X_{11} } &amp; \cdots &amp;\frac{\partial \sigma}{\partial X_{1n} }\\\vdots &amp; \ddots &amp;  \\\frac{\partial \sigma}{\partial X_{m1} } &amp;  &amp; \frac{\partial\sigma}{\partial X_{mn} }\end{matrix}\right]\odot\left[\begin{matrix}dX_{11} &amp; \cdots &amp;dX_{1n}\\\vdots &amp; \ddots &amp;  \\dX_{m1} &amp;  &amp; dX_{mn}\end{matrix}\right]=\frac{\partial \sigma}{\partial X_{} }\odot dX\end{aligned}\]</span></p><ol start="6" type="1"><li><p><span class="math inline">\(d(X\odot Y)=dX\odot Y+X\odotdY\)</span></p></li><li><p><span class="math inline">\(x\)</span>为标量，或1×1矩阵，<span class="math inline">\(x=tr(x)\)</span></p></li><li><p><span class="math inline">\(tr(X^T)=tr(X)\)</span></p></li><li><p><span class="math inline">\(dtr(X)=tr(dX)\)</span></p></li><li><p><span class="math inline">\(tr(XY)=tr(YX)=tr(X^TY^T)\)</span></p></li><li><p><span class="math inline">\(tr(A^T(B\odot C))=tr((A\odotB)^TC)=tr((A^T\odot B^T)C)\)</span> 可以看到，只有<span class="math inline">\(B\)</span>变成了<span class="math inline">\(B^T\)</span></p></li><li><p><span class="math inline">\(u,v\)</span>是维数相同的向量，<span class="math inline">\(\mathbf 1^T(u\odot v)=u^Tv\)</span></p></li><li><p><span class="math inline">\(u,v\)</span>是维数相同的向量，<span class="math inline">\(u^Tv=v^Tu\)</span></p></li><li><p><span class="math inline">\(vec(A+B)=vec(A)+vec(B)\)</span></p></li><li><p><span class="math inline">\(vec(AXB)=(B^T\otimesA)vec(X)\)</span></p></li></ol><h2 id="示例">示例</h2><p>简便起见，将<span class="math inline">\(\frac{\partial f(a)}{\partiala}\)</span>记为<span class="math inline">\(f&#39;(a)\)</span></p><h3 id="简单单层网络">简单单层网络</h3><p>已知 <span class="math display">\[\hat{y}=XW,\quad X\in R^{1\times m},W\in R^{m\times n}\]</span> 损失函数 <span class="math display">\[L=\frac{1}{2}(\hat{y}-y)({\hat{y}-y)^T }\]</span> <span class="math inline">\(W\)</span>更新公式 <span class="math display">\[W-=lr*\frac{\partial L}{\partial W}\]</span> 为了求<span class="math inline">\(\frac{\partial L}{\partialW}\)</span>，根据(*)式先求<span class="math inline">\(dL\)</span> <span class="math display">\[\begin{aligned}dL&amp;=\frac{1}{2}d((\hat{y}-y))({\hat{y}-y)^T}+\frac{1}{2}(\hat{y}-y)d(({\hat{y}-y)^T) }\\&amp;=\frac{1}{2}(XdW)({\hat{y}-y)^T }+\frac{1}{2}(\hat{y}-y)(XdW)^T \\\end{aligned}\]</span> 注意到<span class="math inline">\((\hat{y}-y)^T\)</span>与<span class="math inline">\(dWX\)</span>均为向量，则根据性质13： <span class="math display">\[dL=(XdW)(\hat{y}-y)^T\tag{1}\]</span> 由于 <span class="math display">\[dL=tr(\frac{\partial f}{\partial W}^TdW)\]</span> 则要将(1)式化为<span class="math inline">\(tr(M^TdW)\)</span>形式，以得出<span class="math inline">\(\frac{\partial L}{\partialW}\)</span>。注意到<span class="math inline">\(dL\)</span>为<span class="math inline">\(1\times1\)</span>方阵，于是 <span class="math display">\[dL=tr(dL)=tr((XdW)(\hat{y}-y)^T)=tr((\hat{y}-y)^TXdW)=tr((X^T(\hat{y}-y))^TdW)\]</span> 因此有 <span class="math display">\[\frac{\partial L}{\partial W}=X^T(\hat{y}-y)\]</span></p><h3 id="单隐藏层网络">单隐藏层网络</h3><p>已知 <span class="math display">\[\hat{y}=g(hW_2+b_2),h=g(XW_1+b_1)\\\quad X\in R^{1\times m},W_1\in R^{m\times n},b_1\in R^{1\timesn},W_2\in R^{n\times q},b_2\in R^{1\times q}\]</span> 损失函数 <span class="math display">\[L=\frac{1}{2}(\hat{y}-y)({\hat{y}-y)^T }\]</span> 参数更新公式 <span class="math display">\[W_1=lr*\frac{\partial L}{\partial W_1},W_2-=lr*\frac{\partialL}{\partial W_2},b_1-=lr*\frac{\partial L}{\partialb_1},b_2-=lr*\frac{\partial L}{\partial b_2}\]</span> 在求某个变量的梯度时，暂且将其他变量视为常量。先求<span class="math inline">\(\frac{\partial L}{\partial b_2}\)</span>，由性质11<span class="math display">\[\begin{aligned}dL&amp;=tr(dL)=tr((g&#39;(hW_2+b_2)\odot db_2)(\hat{y}-y)^T)\\&amp;=tr((\hat{y}-y)(g&#39;(hW_2+b_2)^T\odot db_2^T))\\&amp;=tr(((\hat{y}-y)\odot g&#39;(hW_2+b_2))db_2^T)\\&amp;=tr(((\hat{y}-y)\odot g&#39;(hW_2+b_2))^Tdb_2)\end{aligned}\]</span> 于是 <span class="math display">\[\frac{\partial L}{\partial b_2}=(\hat{y}-y)\odot g&#39;(hW_2+b_2)\]</span> 对于<span class="math inline">\(\frac{\partial L}{\partialW_2}\)</span>： <span class="math display">\[\begin{aligned}dL&amp;=tr(dL)=tr((g&#39;(hW_2+b_2)\odot (hdW_2))(\hat{y}-y)^T)\\&amp;=tr((\hat{y}-y)(g&#39;(hW_2+b_2)^T\odot (hdW_2)^T))\\&amp;=tr(((\hat{y}-y)\odot g&#39;(hW_2+b_2))(hdW_2)^T)\\&amp;=tr(((\hat{y}-y)\odot g&#39;(hW_2+b_2))^ThdW_2)\\&amp;=tr(((h^T((\hat{y}-y)\odot g&#39;(hW_2+b_2)))^TdW_2)\end{aligned}\]</span> 于是 <span class="math display">\[\frac{\partial L}{\partial W_2}=h^T((\hat{y}-y)\odot g&#39;(hW_2+b_2))\]</span> 为求<span class="math inline">\(\frac{\partial L}{\partialb_1}\)</span>，<span class="math inline">\(\frac{\partial L}{\partialW_1}\)</span>，根据链式法则，先求出<span class="math inline">\(\frac{\partial L}{\partial h}\)</span> <span class="math display">\[\begin{aligned}dL&amp;=tr(dL)=tr((g&#39;(hW_2+b_2)\odot (dhW_2))(\hat{y}-y)^T)\\&amp;=tr((\hat{y}-y)(g&#39;(hW_2+b_2)^T\odot (dhW_2)^T))\\&amp;=tr(((\hat{y}-y)\odot g&#39;(hW_2+b_2))(dhW_2)^T)\\&amp;=tr(((\hat{y}-y)\odot g&#39;(hW_2+b_2))^TdhW_2)\\&amp;=tr((((\hat{y}-y)\odot g&#39;(hW_2+b_2))W_2^T)^Tdh)\end{aligned}\]</span> 于是 <span class="math display">\[\frac{\partial L}{\partial h}=((\hat{y}-y)\odot g&#39;(hW_2+b_2))W_2^T\]</span> 设<span class="math inline">\(a=XW_1+b_1\)</span>，则<span class="math inline">\(h=g(a)\)</span>，根据链式法则 <span class="math display">\[\frac{\partial L}{\partial a}=\frac{\partial L}{\partial h}\odot\frac{\partial g}{\partial a}\\\frac{\partial L}{\partial b_1}=\frac{\partial L}{\partial a}\\\frac{\partial L}{\partial W_1}=X^T\frac{\partial L}{\partial a}\]</span> 于是得到 <span class="math display">\[\frac{\partial L}{\partial b_1}=(((\hat{y}-y)\odotg&#39;(hW_2+b_2))W_2^T)\odot \frac{\partial g}{\partial a}\\\frac{\partial L}{\partial W_1}=X^T((((\hat{y}-y)\odotg&#39;(hW_2+b_2))W_2^T)\odot \frac{\partial g}{\partial a})\]</span> # 特征值与特征向量</p><p>"There are some matrices for which there are not a full set ofeigenvectors. that's really the main sort of annoying point in the wholesubject of linear algebra is some matrices don't have enougheigenvectors. "</p><p>对于任何一个n阶方阵<span class="math inline">\(A_{n\timesn}\)</span>，它的特征值一定有n个（算上虚特征值和重复特征值），换句话说这等价于实数特征值不超过n个，因为求特征值用<span class="math inline">\(|A-\lambda I|=0\)</span>,最终必定可以化为<span class="math inline">\(\lambda\)</span>的n阶方程，实数解的个数不超过n（代数基本定理）。</p><ul><li>定理1：不同特征值对应的特征向量线性无关。证明：</li></ul><p>设<span class="math inline">\(A\)</span>有两个特征值<span class="math inline">\(\lambda_{1},\lambda_{2}\)</span>和两个对应的特征向量<span class="math inline">\(x_1,x_2\)</span>，且<span class="math inline">\(\lambda_{1}\neq\lambda_{2}\)</span>.假设<span class="math inline">\(x_1,x_2\)</span>线性相关，则<span class="math inline">\(x_1=kx_2\)</span>成立，则<span class="math inline">\(Ax_2=\lambda_2 x_2=Akx_1=kAx_1=k\lambda_1x_1\)</span>,所以(1)当<span class="math inline">\(\lambda_1\ne0\)</span>，有<span class="math inline">\(x_2=\frac{\lambda_1}{\lambda_2}kx_1=kx_1\)</span>,<span class="math inline">\(\lambda_1=\lambda_2\)</span>，矛盾。(2)当<span class="math inline">\(\lambda_1=0\)</span>,因为特征向量非零，所以<span class="math inline">\(\lambda_2=0=\lambda_1\)</span>，矛盾。于是得证</p><h2 id="实数特征值与虚数特征值">实数特征值与虚数特征值</h2><p>从矩阵<span class="math inline">\(A\)</span>的特征值<span class="math inline">\(\lambda\)</span>与特征向量<span class="math inline">\(x\)</span>的计算来看，即<span class="math inline">\(Ax=\lambda x\)</span>，在<span class="math inline">\(x\)</span>方向上，矩阵<span class="math inline">\(A\)</span>只起到了拉伸的作用。若特征值为0，则<span class="math inline">\(A\)</span>将某些向量映射到0空间，这说明<span class="math inline">\(A\)</span>不满秩。若特征值为实数，说明对某些方向上的向量，<span class="math inline">\(A\)</span>仅起到了拉伸的效果，下面将这种矩阵称作拉伸矩阵。若特征值是虚数，说明<span class="math inline">\(A\)</span>对所有方向的向量都起到了旋转的效果，下面将这种矩阵称为旋转矩阵。</p><h3 id="拉伸矩阵">拉伸矩阵</h3><p>对于一个特征向量空间内的向量，拉伸矩阵让一个向量更靠近它最大的特征值对应的特征向量方向。也就是说，在拉伸矩阵的特征向量空间中的向量，一直让它左乘这个拉伸矩阵，那么它最终会逼近最大特征值对应的特征向量方向。为什么要强调是特征向量空间内？因为前面的定理1说明，r个不同特征值可以形成r维特征向量空间，而相同的k重特征值却不一定能形成k维特征向量空间（因为几何重数不大于代数重数，Jordan标准型给出证明）,因此，特征向量空间的维度不一定等于原矩阵的维度（即使原矩阵是满秩的）。因此要强调是特征向量空间内的向量，因为它可以由特征向量表出。</p><p>证明：设矩阵<span class="math inline">\(A_{n\times n}\)</span>有<span class="math inline">\(r\)</span>个不同的特征向量<span class="math inline">\(\lambda_1,...\lambda_r\)</span>，有一个特征向量空间内的向量<span class="math inline">\(x\)</span>,特征向量的基底是<span class="math inline">\(e_1,e_2,...e_r\)</span>,于是 <span class="math display">\[\exists k_1,k_2,...k_n,s.t.\quad x=\sum_{i=1}^rk_ie_i\]</span> 则 <span class="math display">\[\lim_{y\to\infty}A^yx=A^y\sum_{i=1}^rk_ie_i=\sum_{i=1}^rk_iA^ye_i=\sum_{i=1}^rk_i\lambda_i^ye_i\]</span> 容易得知最大的特征值的特征向量方向对结果方向影响最大</p><h3 id="旋转矩阵的分解">旋转矩阵的分解</h3><p>旋转矩阵对所有实数向量都起到了旋转的效果，但也可能起到拉伸效果。事实上，旋转矩阵可以分解成一个纯旋转矩阵和一个拉伸矩阵的矩阵乘积。（<strong>该结论暂未证明</strong>）纯旋转矩阵指的是，左乘纯旋转矩阵只改变向量的方向，而不改变向量的模长。纯旋转矩阵一定是正交矩阵。满足下列关系的矩阵为纯旋转矩阵：<span class="math display">\[\forall \textbf x,k\in[-1,1],cos&lt;\textbf x,A\textbfx&gt;=\frac{\sum_{i=1}^{n}\sum_{j=1}^{n}A_{ij}x_ix_j}{\sum_{i=1}^{n}a_i^2}\equivk\]</span>即旋转矩阵对任意向量的旋转角均相等。这个结论直接计算化简即得。</p><h2 id="相似对角化">相似对角化</h2><p>矩阵<span class="math inline">\(A\)</span>可以相似于对角矩阵<span class="math inline">\(\Lambda\)</span>，当且仅当矩阵<span class="math inline">\(A_{n\timesn}\)</span>有n个线性无关的特征向量。即： <span class="math display">\[\begin{aligned}\Lambda&amp;=P^{-1}AP\\P&amp;=(p_1,p_2,..p_n)\\\Lambda&amp;=\left[\begin{matrix}\lambda_1 &amp;  &amp; \\&amp; \ddots &amp;  \\&amp;  &amp; \lambda_{n}\end{matrix}\right]\end{aligned}\]</span> 其中，<span class="math inline">\(\lambda_i\)</span>对应的特征向量为<span class="math inline">\(p_i\)</span>. 直接计算<span class="math inline">\(AP=P\Lambda\)</span>即可证明。若<span class="math inline">\(A\)</span>相似于对角矩阵，则很容易算<span class="math inline">\(A\)</span>的次方： <span class="math display">\[A^k=P\Lambda^kP^{-1}\]</span></p><h2 id="svd分解">SVD分解</h2><p>现在考虑以下问题：是否存在两个正交二维向量<span class="math inline">\(x_1,x_2\)</span>, 经矩阵<span class="math inline">\(A_{2\times 2}\)</span>变换后，<span class="math inline">\(Ax_1,Ax_2\)</span>是否仍然正交？设<span class="math inline">\(Av_1=\sigma_1 u_1,Av_2=\sigma_2 u_2\)</span>,则</p><h1 id="jordan标准型">Jordan标准型</h1><p>任何n阶方阵可以相似于具有以下形式的矩阵： <span class="math display">\[J_{n\times n}=\left[\begin{matrix}J_1 &amp;  &amp; &amp;\\&amp; J_2&amp; \\  &amp;  &amp; \ddots&amp; \\&amp;  &amp;&amp; J_{k}\end{matrix}\right],J_i=\left[\begin{matrix}\lambda_i &amp;1 &amp; &amp; \\&amp; \lambda_i &amp;1 &amp;  \\  &amp;  &amp;\ddots &amp; \ddots \\&amp; &amp; &amp; \lambda_{i}\end{matrix}\right]\]</span> 其中<span class="math inline">\(\sum_{i=1}^nR(J_i)=n\)</span>.在Gilbert Strang 的 <em>Linear Algebra and Its Applications</em>,Appendix B 一章通过构造<span class="math inline">\(P\)</span>证明了<span class="math inline">\(\forall A\in R^{n\times n},\exists P,s.t.A=P^{-1}JP\)</span>.</p><p>下面分析Jordan型的意义。</p><p>注意小块最后一行，这一行只有一列非零，因此，<span class="math inline">\(|J_i-\lambda_i I|=0\)</span>，<span class="math inline">\(\lambda_i\)</span>是<span class="math inline">\(J\)</span>的特征值。</p><p>接下来考虑<span class="math inline">\(J\)</span>的特征向量。对于小块<span class="math inline">\(J_i\)</span>，<span class="math inline">\((J_i-\lambda_iI)x=0\)</span>的解空间维数为1，因此小块<span class="math inline">\(J_i\)</span>对应一个1维特征向量空间。于是容易理解，代数重数大于等于几何重数的原因。每个小块至少是1维，当小块为1维时，这个小块的特征值对应的特征向量空间是1维，此时代数重数等于几何重数。如果小块大于1维，代数重数大于几何重数，这个小块的代数重数等于小块的维数，特征向量空间是1维。相同的特征值可能对应不同的特征向量，此时不同小块中存在相同的特征值，而这些不同的小块对应不同的特征向量。</p><h1 id="变换">变换</h1><p>矩阵乘向量在几何意义上就是向量的线性变换，满秩矩阵把这个向量映射到同维空间的另一个向量，不满秩矩阵把它映射到低维空间的另一个向量。矩阵乘矩阵在几何意义上是基底变换，一个矩阵的每一列视为一个基底向量，基底变换就是把一组基底映射到另一组基底，满秩矩阵把基底映射到同维空间的另一组基底，不满秩矩阵把基底映射到低维空间的另一组基底。</p><h2 id="基底变换">基底变换</h2><p>一个可逆矩阵可以将一组基底变换到在同维空间中的任意一组基底。这其实就是矩阵乘的意义。设有一组基底<span class="math inline">\((e_1,e_2,...e_n)\)</span>，他们构成矩阵<span class="math inline">\(M\)</span>，其中<span class="math inline">\(e_i\)</span>是<span class="math inline">\(n\times1\)</span>列向量，对于n维空间中任意一组基底构成的矩阵<span class="math inline">\(N\)</span>，设经过左乘矩阵<span class="math inline">\(P\)</span>从<span class="math inline">\(M\)</span>变换到<span class="math inline">\(N\)</span>，则 <span class="math display">\[\begin{aligned}N&amp;=MP\\P&amp;=M^{-1}N\end{aligned}\]</span> 于是可知存在唯一的矩阵<span class="math inline">\(P\)</span>使得基底<span class="math inline">\(M\)</span>变换到基底<span class="math inline">\(N\)</span></p><p>基底变换定理：基底变换不改变向量本身，通过基底变换变的是向量在这组基底下的各个分量的取值。也就是说，在标准正交基下（或者任何一组作为参考的基底）的向量是不变的。基底<span class="math inline">\(M\)</span>经过基底变换得到基底<span class="math inline">\(N\)</span>，即有<span class="math inline">\(N=MP\)</span>，对同一个标准正交基下的向量<span class="math inline">\(\textbf x\)</span>，其在<span class="math inline">\(M,N\)</span>下的分量为<span class="math inline">\(\alpha,\alpha&#39;\)</span>，即有<span class="math inline">\(M\alpha=N\alpha&#39;=\textbfx,\alpha&#39;=P^{-1}\alpha\)</span></p><p>从这个结论来看，向量的线性变换的意义可以归结为以下两个等价的观点：</p><p>1）在基底不变的情况下，<span class="math inline">\(\textbfx\)</span>变换到同基底下的<span class="math inline">\(P\textbfx\)</span></p><p>2）在向量不变的情况下，基底<span class="math inline">\(M\)</span>变换到<span class="math inline">\(PM\)</span>，<span class="math inline">\(\textbfx\)</span>在新基底<span class="math inline">\(PM\)</span>下的分量为<span class="math inline">\(P^{-1}\textbf x\)</span></p><p>这两种观点是等价的，区别只在于选择向量还是基底作为参考，而用两种观点来描述的他们之间的相对关系是一样的。基底不变，向量变等价于向量不变，基底变。</p><h2 id="相似变换">相似变换</h2><p>基底<span class="math inline">\(M\)</span>经过基底变换得到基底<span class="math inline">\(N\)</span>，即有<span class="math inline">\(N=MP\)</span>，对同一个标准正交基下的向量<span class="math inline">\(\textbf x\)</span>，其在<span class="math inline">\(M,N\)</span>下为<span class="math inline">\(\alpha,\alpha&#39;\)</span>，即有<span class="math inline">\(M\alpha=N\alpha&#39;=\textbfx,\alpha&#39;=P^{-1}\alpha\)</span>，<span class="math inline">\(\alpha\)</span>经过线性变换得到向量<span class="math inline">\(\beta\)</span>，即<span class="math inline">\(\beta=A\alpha\)</span>，设<span class="math inline">\(\beta\)</span>在<span class="math inline">\(N\)</span>下为<span class="math inline">\(\beta&#39;\)</span>，于是有<span class="math inline">\(\beta&#39;=P^{-1}\beta\)</span>，设矩阵<span class="math inline">\(A&#39;\)</span>使得<span class="math inline">\(\beta&#39;=A&#39;\alpha&#39;\)</span>，于是 <span class="math display">\[\beta&#39;=A&#39;\alpha&#39;=P^{-1}\beta=P^{-1}A\alpha=P^{-1}AP\alpha&#39;\]</span> 则 <span class="math display">\[A&#39;=P^{-1}AP\tag{2}\]</span>上面的结论说明，一个向量被映射到另一个向量，在两个不同的基底下的两个变换关系之间具有(2)式描述的关系。因此，相似变换是同一个线性变换在不同基底下的不同表现形式。</p><h3 id="相似对角化-1">相似对角化</h3><p>若方阵经相似变换能化为对角矩阵，则这个方阵可相似对角化。</p><p><span class="math inline">\(A_{n\times n}\)</span>可相似对角化<span class="math inline">\(\iff\)</span><span class="math inline">\(A_{n\times n}\)</span>有n个线性无关的特征向量</p><p>证明：充分性：若<span class="math inline">\(A_{n\timesn}\)</span>可相似对角化，设其相似于对角矩阵<span class="math inline">\(B=diag(b_1,b_2,...b_n)\)</span>，且<span class="math inline">\(B=P^{-1}AP\)</span>，则<span class="math inline">\(PB=AP\)</span>. 将<span class="math inline">\(P\)</span>以列向量形式表示，<span class="math inline">\(P={p_{.1},p_{.2},...p_{.n})\)</span> . 因为 <span class="math display">\[PB=(p_{.1},p_{.2},...p_{.n})\]</span> 从几何角度考虑，相似对角化实质上是把原矩阵<span class="math inline">\(A\)</span>对应的基底变换到特征向量方向上，这时新的基底两两正交。</p><h2 id="合同变换">合同变换</h2><p>任意一个二次型 <span class="math display">\[f(\textbf x)=\sum_{i=1}^n\sum_{j=1}^{n} k_{ij}x_ix_j,\textbfx=(x_1,x_2,...x_n)^T\]</span> 均可以化为矩阵乘形式<span class="math inline">\(\textbfx^TA\textbf x\)</span>，可以证明这样的<span class="math inline">\(A\)</span>有无数个。当<span class="math inline">\(A\)</span>为对称矩阵，则<span class="math inline">\(A\)</span>是唯一的，此时有 <span class="math display">\[a_{ij}=\left\{\begin{array}{l}\frac{k_{ij}+k_{ji} }{2},\quad i\neq j \\k_{ij},\quad i=j \\\end{array}\right.\]</span> 当对基底<span class="math inline">\(M\)</span>下的向量<span class="math inline">\(\textbf x\)</span>进行线性变换<span class="math inline">\(C^{-1}\)</span>(为了让结论形式看起来简洁，写成C的逆矩阵。其实只要这里是个可逆矩阵就行)，得到另一个基底<span class="math inline">\(N\)</span>下的向量<span class="math inline">\(\textbf y\)</span>，即<span class="math inline">\(\textbf x=C\textbf y\)</span>，这时<span class="math inline">\(f(\textbf x)=g(\textbf y)=\textbf x^TA\textbfx=\textbf y^TC^TAC\textbf y=\textbf y^TA&#39;\textbf y\)</span>，于是<span class="math display">\[A&#39;=C^TAC\]</span>上面的结论说明，同一个二次型在两个不同的基底下，两个变换关系之间具有(2)式描述的关系。</p><h3 id="惯性定理">惯性定理</h3><p>上面说到，合同变换可以视为同一个二次型在两个不同的基底下的不同的描述形式，因此，我们可以通过变换基底，让二次型只含有平方项，不含有<span class="math inline">\(x_1x_2\)</span>这种混合乘积，并且平方项系数只能为0，1，-1，也就是化成标准型。可以想象，一定存在某一个位置可以达到这种效果，例如一个椭圆，两个基底向量分别它的长轴和短轴重合时，就只含有平方项，将长轴一半和短轴一半长度作为两个基底向量的单位长度，就得到标准型，变成了一个单位圆。事实上，将任意二次型化成标准型存在且只存在一种合同变换。下面证明这个结论。</p><p>证明：设有二次型<span class="math inline">\(f(\textbf x)=g(\textbfy)=\textbf x^TA\textbf x=\textbf y^T B\textbf y\)</span>，其中<span class="math inline">\(B\)</span>为对角矩阵。若证明了<span class="math inline">\(B\)</span>是对角矩阵，则可将<span class="math inline">\(B\)</span>化为只含0，1，-1的对角矩阵。于是原命题等价于证存在<span class="math inline">\(C\)</span>满足<span class="math inline">\(B=C^TAC\)</span>.</p><p>因为<span class="math inline">\(A\)</span>为对称矩阵，根据对称矩阵的结论，存在正交矩阵<span class="math inline">\(P\)</span>使得<span class="math inline">\(A=P^{-1}B P\)</span>，根据正交矩阵的结论，<span class="math inline">\(P^{-1}=P^T\)</span>，于是<span class="math inline">\(B=PAP^T\)</span>，即证</p><p>标准型中正、负号的个数称为正、负惯性系数。因为合同变换是同一个二次型在不同基底下的形式，而将任意二次型化成标准型存在且只存在一种合同变换，因此易知合同变换不改变正负惯性系数。</p><h2 id="正交化">正交化</h2><h3 id="向量投影">向量投影</h3><p>向量<span class="math inline">\(\alpha\)</span>在一组标准正交基<span class="math inline">\(V=(\beta_1,\beta_2,...\beta_m)\)</span>下的投影为<span class="math display">\[proj_V\alpha=\sum_{i=1}^m(\alpha\cdot\beta_i)\beta_i\]</span> 其中，<span class="math inline">\(\alpha,\beta_i\)</span>均为n维向量（<span class="math inline">\(n\ge m\)</span>），<span class="math inline">\(\alpha\cdot\beta_i\)</span>是<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(\beta_i\)</span>方向上投影的向量长度。当<span class="math inline">\(n=m\)</span>时，<span class="math inline">\(\alpha\)</span>可由<span class="math inline">\(V\)</span>线性表出，此时<span class="math inline">\(\alpha=proj_V\alpha\)</span>，当<span class="math inline">\(n&gt; m\)</span>，<span class="math inline">\(\alpha_p=\alpha-proj_V\alpha\)</span>与空间<span class="math inline">\(V\)</span>垂直。这里与空间垂直的意义是，<span class="math inline">\(\alpha_p\)</span>与每个基向量垂直。向量与线和平面垂直的情况容易想象。从想象中可以得到以下定理（<strong>该结论暂未证明</strong>）：所有<span class="math inline">\(\alpha\)</span>对应的<span class="math inline">\(\alpha_p\)</span>形成的向量空间的维度=m-n.</p><h3 id="正交化-1">正交化</h3><p>任意线性无关的一组向量均可以化为该向量空间下的一组标准正交基。</p><p>根据投影定义可以知道，任何一个与向量空间<span class="math inline">\(V\)</span>中所有基向量线性无关的向量<span class="math inline">\(\alpha\)</span>均能表示成这个空间内的投影<span class="math inline">\(proj_V\alpha\)</span>+与这个空间垂直的向量<span class="math inline">\(\alpha_p\)</span>.因此，可以采用如下方法得到一组基<span class="math inline">\((\beta_1,\beta_2,...\beta_m)\)</span>的标准正交基：</p><p>1）取第一个向量<span class="math inline">\(\beta_1\)</span>，将其归一化，加入到子空间<span class="math inline">\(W\)</span>中</p><p>2）取第k(k&gt;1)个向量<span class="math inline">\(\beta_k\)</span>，计算其与子空间<span class="math inline">\(W\)</span>垂直的向量<span class="math inline">\(\beta_{kp}=\beta-proj_V\beta_{k}\)</span>，并将<span class="math inline">\(\beta_{kp}\)</span>归一化，加入到<span class="math inline">\(W\)</span>中</p><p>3）重复2），直到k=n</p><h3 id="正交向量空间">正交向量空间</h3><p>若k维空间<span class="math inline">\(V\)</span>中的一组基<span class="math inline">\((\alpha_1,...\alpha_k)\)</span>与另一r维空间<span class="math inline">\(W\)</span>中的一组基<span class="math inline">\((\beta_1,...\beta_r)\)</span>正交(<span class="math inline">\(\alpha_i,\beta_j\)</span>为同维向量)，则空间<span class="math inline">\(V\)</span>与空间<span class="math inline">\(W\)</span>中所有向量均正交。</p><p>证明：设<span class="math inline">\(V\)</span>中一向量<span class="math inline">\(\alpha=\sum_{i=1}^{k}m_i\alpha_i\)</span>,<span class="math inline">\(W\)</span>中一向量<span class="math inline">\(\beta=\sum_{i=1}^{r}n_i\beta_i\)</span>, 则 <span class="math display">\[\alpha \cdot\beta=(\sum_{i=1}^{k}m_i\alpha_i)(\sum_{i=1}^{r}n_i\beta_i)=\sum_{i=1}^{k}\sum_{j=1}^r(m_in_j\alpha_i\cdot\beta_j)=0\]</span> 于是两空间中任意向量均正交。</p><h1 id="特殊矩阵">特殊矩阵</h1><h2 id="正交矩阵">正交矩阵</h2><ul><li>正交矩阵满足<span class="math inline">\(A^{-1}=A^T\)</span></li></ul><p>将矩阵写成列向量形式<span class="math inline">\(A=(a_1,a_2,...a_n)\)</span>，若 <span class="math display">\[a_i\cdot a_{j}=\left\{\begin{array}{l}0,\quad i\neq j \\1,\quad i=j \\\end{array}\right.\]</span> 则<span class="math inline">\(A\)</span>为正交矩阵。</p><p>若<span class="math inline">\(A\)</span>为正交矩阵，则<span class="math inline">\(A^TA=I\)</span>，因为 <span class="math display">\[A^TA=\left(\begin{matrix}a_1^T \\a_2^T    \\...\\a_n^T\end{matrix}\right)(a_1,a_2,...a_n)=\left(\begin{matrix}a_1^Ta_1 &amp;a_1^Ta_2 &amp;...  \\a_2^Ta_1 &amp; \ddots &amp;  \\...&amp;  &amp; a_n^Ta_n\end{matrix}\right)=I\]</span> 于是可得<span class="math inline">\(A^{-1}=A^T\)</span></p><h2 id="对称矩阵">对称矩阵</h2><ul><li>任何一个矩阵 A可以表示为一个反对称矩阵M + 一个对称矩阵S</li></ul><p>证明：如果原命题成立，只要证明存在这样的<span class="math inline">\(M\)</span>和<span class="math inline">\(N\)</span>，因为 <span class="math display">\[\begin{aligned}A_{ij}&amp;=M_{ij}+S_{ij}\\A_{ji}&amp;=M_{ji}+S_{ji}=-M_{ji}+S_{ij}\end{aligned}\]</span> 两个未知数<span class="math inline">\(A_{ij},A_{ji}\)</span>两个等式可以解出两个未知数<span class="math inline">\(M_{ij},S_{ij}\)</span>，即证</p><ul><li>矩阵<span class="math inline">\(A\)</span>是实对称矩阵<span class="math inline">\(\iff\)</span><span class="math inline">\(A=P^{-1}\Lambda P\)</span>，<span class="math inline">\(\Lambda\)</span>是对角矩阵，<span class="math inline">\(P\)</span>是正交矩阵</li></ul><p>证明：1）充分性：若<span class="math inline">\(A\)</span>为实对称矩阵，设<span class="math inline">\(J=P^{-1}AP\)</span>, <span class="math inline">\(J\)</span>为Jordan矩阵。假设<span class="math inline">\(A\)</span>不可对角化，则<span class="math inline">\(J\)</span>存在维数大于1的小块。不妨设<span class="math inline">\(J_1\)</span>维数大于1，即 <span class="math display">\[J_1=\left[\begin{matrix}\lambda_1 &amp;1 &amp; &amp; \\&amp; \lambda_1 &amp;\ddots &amp;  \\  &amp;  &amp;\ddots &amp;  \\\end{matrix}\right]\]</span> 令<span class="math inline">\(B=P^TP\)</span>，则<span class="math inline">\(B\)</span>为对称矩阵，<span class="math inline">\(b_{12}=b_{21}\)</span>，且<span class="math inline">\(b_{11}=\sum_{i=1}^{n}p_{i1}^2\)</span>，因为<span class="math inline">\(P\)</span>可逆，所以<span class="math inline">\(p_{i1}\)</span>不全为0，<span class="math inline">\(b_{11}&gt;0\)</span>. 因为<span class="math inline">\(P^TAP=P^TPJ=BJ\)</span>, <span class="math inline">\(PAP^T\)</span>为对称矩阵，则<span class="math inline">\(BJ\)</span>为对称矩阵。因为<span class="math inline">\(BJ\)</span>第1行第2列元素为<span class="math inline">\(b_{11}+\lambda_1b_{12}\)</span>，第2行第1列元素为<span class="math inline">\(\lambda_1b_{21}\)</span>，则<span class="math inline">\(BJ\)</span>为非对称矩阵，矛盾。因此<span class="math inline">\(A\)</span>可对角化。</p><p>下面证明实对称矩阵<span class="math inline">\(A\)</span>不同特征值对应的特征向量之间相互正交。</p><p>设<span class="math inline">\(\alpha_1,\alpha_2\)</span>是<span class="math inline">\(A\)</span>的两个不同的特征向量，<span class="math inline">\(A\alpha_1=\lambda_1\alpha_1,A\alpha_2=\lambda_2\alpha_2\)</span>,且<span class="math inline">\(\lambda_2\ne\lambda_1\)</span>,分别左乘<span class="math inline">\(\alpha_2^T,\alpha_1^T\)</span>,则<span class="math inline">\(\alpha_2^TA\alpha_1=\lambda_1\alpha_2^T\alpha_1,\alpha_1^TA\alpha_2=\lambda_2\alpha_1^T\alpha_2\)</span>,因为向量数乘可交换，所以<span class="math inline">\(\alpha_2^TA\alpha_1=(A\alpha_2)^T\alpha_1=\alpha_1^T(A\alpha_2)=\alpha_1^TA\alpha_2\)</span>,于是<span class="math inline">\(\lambda_2\alpha_1^T\alpha_2=\lambda_1\alpha_2^T\alpha_1\)</span>,<span class="math inline">\((\lambda_2-\lambda_1)\alpha_1^T\alpha_2=0\)</span>,则<span class="math inline">\(\alpha_1^T\alpha_2=0\)</span>.</p><p>因此<span class="math inline">\(A\)</span>的不同特征值对应的特征向量构成正交向量空间，在每个r维特征向量空间中选取r个线性无关的模长为1的向量，按列构成矩阵<span class="math inline">\(P\)</span>即可。</p><p>2）必要性：若<span class="math inline">\(A=P^{-1}\LambdaP\)</span>，<span class="math inline">\(\Lambda\)</span>是对角矩阵，<span class="math inline">\(P\)</span>是正交矩阵，则<span class="math inline">\(P^{-1}=P^T,A=P^T\LambdaP,A^T=P^T\Lambda^TP=P^T\Lambda P=A\)</span>, 则<span class="math inline">\(A\)</span>为对称矩阵。下面证明<span class="math inline">\(A\)</span>的特征值均为实数。</p><p>设<span class="math inline">\(Ax=\lambda x\)</span>, <span class="math inline">\(\lambda=a+bi\)</span>, <span class="math inline">\(\bar{x}^TAx=\lambda \bar{x}^Tx\)</span>,直接计算可证<span class="math inline">\(\bar{AB}=\bar{A}\bar{B}\)</span>, 因此<span class="math inline">\(\bar{x}^TAx=\bar{x}^T\bar{A}^Tx=(\bar{Ax})^Tx=\lambda\bar{x}^Tx\)</span>, 于是<span class="math inline">\(\bar{Ax}=\lambda\bar{x}\)</span>, 则<span class="math inline">\(Ax=\bar{\lambda}x\)</span>, 则<span class="math inline">\(b=0\)</span>. 因此<span class="math inline">\(A\)</span>所有特征值为实数。</p><h2 id="正定矩阵">正定矩阵</h2><p>若实对称矩阵所有特征值均&gt;0,则为正定，若均<span class="math inline">\(\ge0\)</span>, 则为半正定，均&lt;0为负定矩阵。</p><p>从几何意义考虑，一个正定矩阵<span class="math inline">\(A_{n\timesn}\)</span>满足<span class="math inline">\(\forall x\in R^{n\times1},x^TAx&gt;0\)</span>，这表明向量<span class="math inline">\(x\)</span>与<span class="math inline">\(Ax\)</span>的内积为正，如对于二，三维向量就是夹角小于<span class="math inline">\(\frac{\pi}{2}\)</span>.</p><h1 id="eulers-formula">Euler's Formula</h1><h2 id="transition">Transition</h2><p>​ It is known the natural logarithm can be defined as: <span class="math display">\[e=\displaystyle\lim_{ x \to \infty}(1+\frac{ 1}{ x})^x\]</span> ​ If we want to popularize it to imaginary, one form ismeaningful: <span class="math display">\[f(e)=\displaystyle\lim_{x \to \infty}(1+\frac{i}{x})^x\]</span> ​ I use <span class="math inline">\(\mit f\)</span><span class="math inline">\((e)\)</span> to stand the result we get. It is animaginary number, in other words it can be expressed as: <span class="math display">\[f(e)=a+bi\]</span> ​ It is worth noting that <span class="math inline">\(f\)</span><span class="math inline">\((e)\)</span>has another form, actually every power of e has this property. <span class="math display">\[\displaystyle\lim_{x \to \infty}(1+\frac{i}{x})^x=\displaystyle\lim_{x\to \infty}((1+\frac{i}{x})^{\frac{x}{i} })^i=e^i=a+bi\]</span> ​ It seems just a trick of mathematic manipulation. However, itbring us a lot convenience in the future steps. We will see its powersoon.</p><p>​ The next goal is to find the <span class="math inline">\(\mit{a}\)</span> and <span class="math inline">\(\mit{b}\)</span>. To achieve this, we should knowsome interesting property and mathematic meaning of the imaginarynumber.</p><p>##Imaginary number and rotary</p><p>​ Frankly speaking I had been confused by imaginary number for a longtime, until I got it can solve rotary problems one day. Let's see anexample, suppose we have two imaginary number <span class="math inline">\({\mit{a} }=r_1(cos\alpha_{1}+{\mit{i}}sin\beta_{1})\)</span> and <span class="math inline">\({\mit{b}}=r_2(cos\alpha_{2}+{\mit{i}}sin\beta_{2})\)</span> , then consider the multiplication of <span class="math inline">\(\mit{a}\)</span> and <span class="math inline">\(b\)</span>: <span class="math display">\[\begin{aligned}a\timesb&amp;=r_1r_2(cos\alpha_{1}cos\alpha_{2}-sin\alpha_{1}sin\alpha_{2}+{\mit{i}}   (cos\alpha_1sin\alpha_2+cos\alpha_2sin\alpha_1))\\&amp;= r_1r_2(cos(\alpha_1+\alpha_2)+isin(\alpha_1+\alpha_2))\end{aligned}\]</span> ​ Look, the multiplication of <span class="math inline">\(\mit{a}\)</span> and <span class="math inline">\(\mit{b}\)</span> results to a new imaginarynumber, whose argument is the sum of that of <span class="math inline">\(\mit{a}\)</span> and <span class="math inline">\(\mit{b}\)</span> and the length is themultiplication of that of <span class="math inline">\(\mit{a}\)</span>and <span class="math inline">\(\mit{b}\)</span>. In fact, this propertycan be popularized to the multiplication of <span class="math inline">\(\mit{n}\)</span> imaginary numbers or an imaginaryto the power of <span class="math inline">\(n\)</span>, as following:<span class="math display">\[\begin{aligned}a^n&amp;=(r(cos\alpha+isin\alpha))^n=r^n(cos(n\alpha)+isin(n\alpha))\quad(n\inR)\end{aligned}\]</span></p><p>​ It will help us in the next step.</p><p>##When comes to infinite</p><p>​ It is said above <span class="math inline">\(e^i=\displaystyle\lim_{x \to\infty}(1+\frac{i}{x})^x\)</span> is an imaginary number, so we need toconsider two aspects of it: argument and length. It is themultiplication of many <span class="math inline">\((1+\frac{i}{x})\)</span>s. Let me give it a name,called <span class="math inline">\({\mit{I}}\)</span> (Just think it isan individual of the big population). Then the argument of <span class="math inline">\(e^i\)</span> will be: <span class="math display">\[arg(e^i)=x\times arg(I)\quad(x \to \infty)\]</span> And the tangent of the argument of <span class="math inline">\(\mit{i}\)</span> is: <span class="math display">\[tan(arg(I))=\frac{1}{x}\quad(x \to \infty)\]</span> So we can get the argument of <span class="math inline">\(e^i\)</span> : <span class="math display">\[\displaystyle\lim_{x \to \infty}arg(e^i)=\displaystyle\lim_{x \to\infty}x\times arctan\frac{1}{x}=\displaystyle\lim_{t \to0}\frac{arctan\,t}{t}=1\]</span> This transformation can be derived by L'Hôpital's rule. Thenconsider the length of <span class="math inline">\(e^i\)</span>: <span class="math display">\[L(e^i)=L(I)^x\quad(x\to \infty)\]</span> And the length of <span class="math inline">\(I\)</span> is:<span class="math display">\[L(I)=\sqrt{1+\frac{1}{x^2} }\quad(x\to\infty)\]</span> So we can get the length of <span class="math inline">\(e^i\)</span>: <span class="math display">\[L(e^i)=\displaystyle\lim_{x \to \infty}({\sqrt{1+\frac{1}{x^2} }})^x=\displaystyle\lim_{x \to \infty}({ {1+\frac{1}{x^2} }})^{\frac{x}{2} }=\displaystyle\lim_{x \to \infty}(({ {1+\frac{1}{x^2} }})^{ {x^2} })^\frac{1}{2x}=\displaystyle\lim_{x \to\infty}e^{\frac{1}{2x} }=1\]</span> The argument and the length of <span class="math inline">\(e^i\)</span> are both 1, so <span class="math inline">\(e^i=cos1+isin1\)</span>. Then we can deriveEuler's formula: <span class="math display">\[e^{i\theta}=(e^i)^\theta=(cos1+isin1)^\theta=cos\theta+isin\theta\]</span></p><h1 id="傅里叶变换">傅里叶变换</h1><p>​任意函数可以表示为一系列三角函数的和。通过傅里叶变换找出这些三角函数。实际应用上，即使不知道函数的表达式，也可以通过傅里叶变换将其转换为频率函数，以获取原函数的性质。</p><!--more--><h2 id="正交函数系">正交函数系</h2><p><span class="math display">\[\forall i,j\in N,s.t.\int_{a}^{b} f_i(x)f_j(x)dx=\left\{\begin{array}{l}0,\quad i\neq j \\1,\quad i=j \\\end{array}\right.\]</span></p><p>则所有<span class="math inline">\(f_i(x)\)</span>构成正交函数系。</p><p>结论：在一定区间<span class="math inline">\((a,b)\)</span>上，正交函数系可以表出任意函数。根据这个结论，可以将任意函数转换为许多带系数正交函数的和，即：<span class="math display">\[\forall f(x),\exists{a_k},f_{m_k}(x),s.t.f(x)=\sum_{k=1}^{n}a_kf_{m_k}(x)\]</span> 那么，对于具体的<span class="math inline">\(f(x)\)</span>，是否可以找出这些<span class="math inline">\(a_k\)</span>和<span class="math inline">\(f_{m_k}(x)\)</span>?这就是傅里叶变换要做的事。</p><p>上述结论证明：</p><p>希望找到一组<span class="math inline">\(a_k,f_{m_k}(x)\)</span>，使得<span class="math inline">\(f(x)=\sum_{k=1}^{n}a_kf_{m_k}(x)\)</span>，因此，考虑其中一个正交函数<span class="math inline">\(f_{m_n}(x)\)</span>，令<span class="math inline">\(f^{(1)}(x)=f(x)-a_nf_{m_n}(x)\)</span>，如果能证明<span class="math display">\[\int_{a}^{b} [f^{(1)}(x)]^2dx&lt;\int_{a}^{b} [f(x)]^2dx\tag{1}\]</span> 则说明<span class="math inline">\(f^{(1)}(x)\)</span>比<span class="math inline">\(f(x)\)</span>更贴近x轴。同样的，可以证明 <span class="math display">\[0=\int_{a}^{b} [f^{(n)}(x)]^2dx&lt;...&lt;\int_{a}^{b}[f^{(1)}(x)]^2dx&lt;\int_{a}^{b} [f(x)]^2dx\tag{2}\]</span>即原函数每次减去某个正交函数后，都会得到一个更贴近x轴的函数，直到缩减到0.而<span class="math display">\[\begin{aligned}&amp;\int_{a}^{b} [f^{(1)}(x)]^2dx&lt;\int_{a}^{b} [f(x)]^2dx\\&amp;\Leftarrow \int_{a}^{b} [f(x)]^2dx-\int_{a}^{b}2a_nf(x)f_{m_n}(x)dx+\int_{a}^{b} [a_nf_{m_n}(x)]^2dx&lt;\int_{a}^{b}[f(x)]^2dx\\&amp;\Leftarrow a_n&lt;\int_{a}^{b} 2f(x)f_{m_n}(x)dx\end{aligned}\]</span> 由于<span class="math inline">\(a_n\)</span>为常数，于是必定存在满足条件的<span class="math inline">\(a_n\)</span>，使得式(1)能成立，同理可证明式(2).</p><p>在傅里叶变换中用三角函数系 <span class="math display">\[\{ sinmx,cosmx|m\in N\}\]</span> 容易证明三角函数系满足正交函数系的条件.</p><h2 id="傅里叶级数">傅里叶级数</h2><p>​由上一节的结论，可知在一定区间上，正交函数系可以表出任意函数。选用三角函数系的原因在于便于找出这些正交函数的系数。换句话说，正交函数系是无穷多的，我们只用便于计算的。傅里叶级数就是把任意函数表示成确定系数的三角函数的和。</p><p>任意函数<span class="math inline">\(f(x)\)</span>用三角函数系表示为：<span class="math display">\[f(x)=\sum_{k=0}^{\infty}(a_ksinkx+b_kcoskx)\tag{3}\]</span> 要计算出<span class="math inline">\(a_k,b_k\)</span>，用正交函数的积分性质： <span class="math display">\[\int_{-\pi}^{\pi} f(x)sinkxdx=\int_{-\pi}^{\pi}a_ksin^2kxdx=\pia_k\tag{4}\\\int_{-\pi}^{\pi} f(x)coskxdx=\int_{-\pi}^{\pi}a_kcos^2kxdx=\pi b_k\]</span> 注意在三角函数系中只有在周期<span class="math inline">\(2\pi\)</span>上才是正交函数系。为此，希望将周期扩展到任意周期<span class="math inline">\(2L\)</span>，这样，当<span class="math inline">\(L\rightarrow\infty\)</span>，则可将任意函数用三角函数系表出。令 <span class="math display">\[t=\frac{Lx}{\pi}\]</span> 于是式(3)转化为： <span class="math display">\[g(t)=f(x)=f(\frac{\pi t}{L})=\sum_{k=0}^{\infty}(a_ksin\frac{k\pit}{L}+b_kcos\frac{k\pi t}{L})\tag{5}\]</span> 将式(4)中所有<span class="math inline">\(f(*)\)</span>换成<span class="math inline">\(g(*)\)</span> <span class="math display">\[a_k=\frac{1}{L}\int_{-L}^{L} g(t)sin\frac{k\pi t}{L}dt\\b_k=\frac{1}{L}\int_{-L}^{L} g(t)cos\frac{k\pi t}{L}dt\tag{6}\]</span></p><h2 id="频率函数">频率函数</h2><p>​上一节的结论说明任意一个函数可以表示成一系列三角函数之和，为方便表示，令<span class="math inline">\(w_0=\frac{\pi}{L}\)</span>，当<span class="math inline">\(L\rightarrow \infty\)</span>，<span class="math inline">\(w_0\rightarrow 0\)</span>，则<span class="math inline">\(kw_0,(k\in N)\)</span>连续。则 <span class="math display">\[\begin{aligned}g(t)&amp;=\sum_{k=0}^{\infty}(a_ksin\frac{k\pi t}{L}+b_kcos\frac{k\pit}{L})\\&amp;=\sum_{k=0}^{\infty}[(sin\frac{k\pi t}{L})\frac{1}{L}\int_{-L}^{L}g(t)sin\frac{k\pi t}{L}dt+(cos\frac{k\pi t}{L})\frac{1}{L}\int_{-L}^{L}g(t)cos\frac{k\pi t}{L}dt]\\&amp;=\lim_{w_0 \to0}\sum_{k=0}^{\infty}\frac{w_0}{\pi}[sinkw_0t\int_{-\frac{\pi}{w_0}}^{\frac{\pi}{w_0}}g(t)sin(kw_0t)dt+coskw_0t\int_{-\frac{\pi}{w_0}}^{\frac{\pi}{w_0}}g(t)cos(kw_0t)dt]\end{aligned}\tag{7}\]</span>根据积分定义，大区间分成的所有同阶无穷小区间上的任意一点（以下为取小区间左点）函数值的累和为该大区间上的积分：<span class="math display">\[\lim_{\Delta x\to 0,n\to \infty}\sum_{i=0}^{n-1}f(\Delta xi)\Deltax=\int_{0}^{\infty}f(x)dx\tag{8}\]</span> 在式(7)中，注意到<span class="math inline">\(w_0\)</span>为无穷小量，可以将其化为对变量<span class="math inline">\(w\)</span>的积分，因此，(7)(8)有以下对应关系：<span class="math display">\[w_0 \iff \Delta x,f(\Delta xi)\iff\frac{1}{\pi}[sinkw_0t\int_{-\frac{\pi}{w_0}}^{\frac{\pi}{w_0}}g(t)sin(kw_0t)dt+coskw_0t\int_{-\frac{\pi}{w_0}}^{\frac{\pi}{w_0}}g(t)cos(kw_0t)dt]\]</span> 进一步可以得出<span class="math inline">\(f(\Deltaxi)\)</span>的一般形式： <span class="math display">\[f(w)=\frac{1}{\pi}[sinwt\int_{-\infty}^{\infty}g(t)sin(wt)dt+coswt\int_{-\infty}^{\infty} g(t)cos(wt)dt]\]</span> 注意到式(7)中的积分 <span class="math display">\[\int_{-\frac{\pi}{w_0}}^{\frac{\pi}{w_0}} g(t)sin(kw_0t)dt\]</span> 在给定<span class="math inline">\(kw_0\)</span>情况下是一个数值，即在实数范围<span class="math inline">\(R\)</span>上对<span class="math inline">\(t\)</span>的积分，积分上下限即为<span class="math inline">\((-\infty,\infty)\)</span></p><p>于是得到傅里叶变换的一种形式 <span class="math display">\[\begin{aligned}g(t)&amp;=\int_{0}^{\infty} f(w)dw\\f(w)&amp;=\frac{1}{\pi}[sinwt\int_{-\infty}^{\infty}g(t)sin(wt)dt+coswt\int_{-\infty}^{\infty} g(t)cos(wt)dt]\end{aligned}\tag{9}\]</span> 上面的<span class="math inline">\(w\)</span>是三角函数的频率，这组公式揭示了：任意一个函数<span class="math inline">\(g(t)\)</span>等价于无穷多组三角函数（无初相）的和，这些三角函数的频率由第二个公式确定，得到一个频率函数<span class="math inline">\(f(w)\)</span>。根据这些三角函数的频率函数<span class="math inline">\(f(w)\)</span>同样能得到原函数<span class="math inline">\(g(t)\)</span></p><h2 id="一般形式">一般形式</h2><p>在常见的傅里叶变换公式中，一般用如下形式： <span class="math display">\[F(w)=\int_{-\infty}^{\infty} f(t)e^{-iwt}dt\\f(t)=\frac{1}{2\pi}\int_{-\infty}^{\infty}F(w)e^{iwt}dw\tag{10}\]</span>式(10)实际上与式(9)等价。式(10)更简洁，将三角函数用欧拉公式转换成指数形式，且更易计算。下面从(9)推到(10):</p><p>用欧拉公式 <span class="math display">\[e^{i\theta}=cos\theta+isin\theta\]</span> 于是 <span class="math display">\[cos\theta=\frac{e^{i\theta}+e^{-i\theta}}{2}\\sin\theta=-i\frac{e^{i\theta}-e^{-i\theta}}{2}\]</span> 带入(9)中<span class="math inline">\(f(w)\)</span> <span class="math display">\[\begin{aligned}f(w)&amp;=\frac{1}{\pi}[-i\frac{e^{iwt}-e^{-iwt} }{2}\int_{-\infty}^{\infty} g(t)(-i\frac{e^{iwt}-e^{-iwt}}{2})dt+\frac{e^{iwt}+e^{-iwt}}{2}\int_{-\infty}^{\infty}g(t)\frac{e^{iwt}+e^{-iwt} }{2}dt]\\&amp;=\frac{1}{\pi}[-(e^{iwt}-e^{-iwt} ) \int_{-\infty}^{\infty}g(t)(\frac{e^{iwt}-e^{-iwt}}{2})dt+(e^{iwt}+e^{-iwt})\int_{-\infty}^{\infty}g(t)\frac{e^{iwt}+e^{-iwt} }{2}dt]\\&amp;=\frac{1}{\pi}[e^{iwt} \int_{-\infty}^{\infty} g(t)\frac{e^{-iwt}}{2}dt+e^{-iwt} \int_{-\infty}^{\infty} g(t)\frac{e^{iwt} }{2}dt]\\&amp;=\frac{e^{iwt}+e^{-iwt} }{2\pi}\int_{-\infty}^{\infty}g(t)e^{-iwt}dt\end{aligned}\]</span> 令 <span class="math display">\[F(w)=\int_{-\infty}^{\infty} g(t)e^{-iwt}dt\]</span> 注意<span class="math inline">\(F(w)=F(-w)\)</span>，于是<span class="math display">\[\begin{aligned}g(t)&amp;=\int_{0}^{\infty} f(w)dw\\&amp;= \int_{0}^{\infty}\frac{e^{iwt}+e^{-iwt} }{2\pi} F(w)dw\\&amp;=\frac{1}{2\pi}[\int_{0}^{\infty}  F(w)e^{iwt}dw+\int_{0}^{\infty}F(w)e^{-iwt}dw]\\&amp;=\frac{1}{2\pi}[\int_{0}^{\infty}  F(w)e^{iwt}dw+\int_{-\infty}^{0}F(w)e^{iwt}dw]\\&amp;=\frac{1 }{2\pi}\int_{-\infty}^{\infty} F(w)e^{iwt}dw\end{aligned}\]</span> 即得到一般形式傅里叶变换</p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL</title>
    <link href="/2022/04/04/SQL/"/>
    <url>/2022/04/04/SQL/</url>
    
    <content type="html"><![CDATA[<h2 id="一般格式">一般格式</h2><h3 id="选择列">选择列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-operator">|</span>cols [<span class="hljs-keyword">AS</span> nickname] <span class="hljs-keyword">FROM</span> tableA<br>[<span class="hljs-keyword">JOIN</span> tableB <span class="hljs-keyword">ON</span> connection_A_B]<br>[<span class="hljs-keyword">WHERE</span> conditions]<br></code></pre></td></tr></table></figure><h3 id="选择计算函数">选择计算函数</h3><p>下面的cal_func(col) 包括 SUM(col)，AVG(col)，COUNT(col)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cal_func(col) [<span class="hljs-keyword">AS</span> nickname] <span class="hljs-keyword">FROM</span> tableA<br>[<span class="hljs-keyword">JOIN</span> tableB <span class="hljs-keyword">ON</span> connection_A_B]<br>[<span class="hljs-keyword">WHERE</span> conditions]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> columns_name [<span class="hljs-keyword">HAVING</span> conditions]] <span class="hljs-comment">--按照列的取值分组</span><br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column_name <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>] <span class="hljs-comment">--按某列值升序降序排列</span><br></code></pre></td></tr></table></figure><p>GROUP BY如果有多列，则会返回笛卡尔积，例如下面的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">order_date <span class="hljs-operator">|</span> product_name <span class="hljs-operator">|</span> customer_name <span class="hljs-operator">|</span> sales<br><span class="hljs-comment">-----------|-------------|---------------|-------</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span> <span class="hljs-operator">|</span> Product A   <span class="hljs-operator">|</span> Customer <span class="hljs-number">1</span>    <span class="hljs-operator">|</span> <span class="hljs-number">100</span> <br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-operator">|</span> Product B   <span class="hljs-operator">|</span> Customer <span class="hljs-number">2</span>    <span class="hljs-operator">|</span> <span class="hljs-number">150</span> <br><span class="hljs-number">2022</span><span class="hljs-number">-03</span><span class="hljs-number">-15</span> <span class="hljs-operator">|</span> Product C   <span class="hljs-operator">|</span> Customer <span class="hljs-number">3</span>    <span class="hljs-operator">|</span> <span class="hljs-number">200</span> <br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-20</span> <span class="hljs-operator">|</span> Product A   <span class="hljs-operator">|</span> Customer <span class="hljs-number">4</span>    <span class="hljs-operator">|</span> <span class="hljs-number">50</span>  <br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-25</span> <span class="hljs-operator">|</span> Product B   <span class="hljs-operator">|</span> Customer <span class="hljs-number">5</span>    <span class="hljs-operator">|</span> <span class="hljs-number">75</span>  <br><span class="hljs-number">2022</span><span class="hljs-number">-03</span><span class="hljs-number">-30</span> <span class="hljs-operator">|</span> Product C   <span class="hljs-operator">|</span> Customer <span class="hljs-number">6</span>    <span class="hljs-operator">|</span> <span class="hljs-number">125</span> <br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MONTH</span>(order_date) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">month</span>, product_name, <span class="hljs-built_in">SUM</span>(sales) <span class="hljs-keyword">AS</span> total_sales<br><span class="hljs-keyword">FROM</span> sales_data<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">MONTH</span>(order_date), product_name;<br></code></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">month</span> <span class="hljs-operator">|</span> product_name <span class="hljs-operator">|</span> total_sales<br><span class="hljs-comment">------|--------------|------------</span><br><span class="hljs-number">1</span>     <span class="hljs-operator">|</span> Product A    <span class="hljs-operator">|</span> <span class="hljs-number">150</span><br><span class="hljs-number">1</span>     <span class="hljs-operator">|</span> Product B    <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span>     <span class="hljs-operator">|</span> Product C    <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br><span class="hljs-number">2</span>     <span class="hljs-operator">|</span> Product A    <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br><span class="hljs-number">2</span>     <span class="hljs-operator">|</span> Product B    <span class="hljs-operator">|</span> <span class="hljs-number">225</span><br><span class="hljs-number">2</span>     <span class="hljs-operator">|</span> Product C    <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span>     <span class="hljs-operator">|</span> Product A    <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span>     <span class="hljs-operator">|</span> Product B    <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span>     <span class="hljs-operator">|</span> Product C    <span class="hljs-operator">|</span> <span class="hljs-number">325</span><br></code></pre></td></tr></table></figure><h2 id="join">JOIN</h2><p>对于如下的两个表：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">A<br>╔════╦═══════╗<br>║ Id ║ Value ║<br>╠════╬═══════╣<br>║ <span class="hljs-number"> 1 </span>║   <span class="hljs-number"> 10 </span>║<br>║ <span class="hljs-number"> 2 </span>║   <span class="hljs-number"> 20 </span>║<br>║ <span class="hljs-number"> 3 </span>║   <span class="hljs-number"> 30 </span>║<br>╚════╩═══════╝<br>B<br>╔════╦════════╗<br>║ Id ║  Name  ║<br>╠════╬════════╣<br>║ <span class="hljs-number"> 1 </span>║ Alice  ║<br>║ <span class="hljs-number"> 2 </span>║ Bob    ║<br>╚════╩════════╝<br></code></pre></td></tr></table></figure><h3 id="inner-join">(INNER) JOIN</h3><p>通过公共部分将两个表连接为一个表。</p><p>执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.Id <span class="hljs-operator">=</span> B.Id;<br></code></pre></td></tr></table></figure><p>得到</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">╔════╦═══════╦════╦════════╗<br>║ Id ║ Value ║ Id ║  Name  ║<br>╠════╬═══════╬════╬════════╣<br>║ <span class="hljs-number"> 1 </span>║   <span class="hljs-number"> 10 </span>║ <span class="hljs-number"> 1 </span>║ Alice  ║<br>║ <span class="hljs-number"> 2 </span>║   <span class="hljs-number"> 20 </span>║ <span class="hljs-number"> 2 </span>║ Bob    ║<br>╚════╩═══════╩════╩════════╝<br></code></pre></td></tr></table></figure><h3 id="cross-join">CROSS JOIN</h3><p>两个表按行组合。</p><p>执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> B;<br></code></pre></td></tr></table></figure><p>得到</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">╔════╦═══════╦════╦════════╗<br>║ Id ║ <span class="hljs-keyword">Value</span> ║ Id ║  Name  ║<br>╠════╬═══════╬════╬════════╣<br>║  <span class="hljs-number">1</span> ║    <span class="hljs-number">10</span> ║  <span class="hljs-number">1</span> ║ Alice  ║<br>║  <span class="hljs-number">1</span> ║    <span class="hljs-number">10</span> ║  <span class="hljs-number">2</span> ║ Bob    ║<br>║  <span class="hljs-number">2</span> ║    <span class="hljs-number">20</span> ║  <span class="hljs-number">1</span> ║ Alice  ║<br>║  <span class="hljs-number">2</span> ║    <span class="hljs-number">20</span> ║  <span class="hljs-number">2</span> ║ Bob    ║<br>║  <span class="hljs-number">3</span> ║    <span class="hljs-number">30</span> ║  <span class="hljs-number">1</span> ║ Alice  ║<br>║  <span class="hljs-number">3</span> ║    <span class="hljs-number">30</span> ║  <span class="hljs-number">2</span> ║ Bob    ║<br>╚════╩═══════╩════╩════════╝<br></code></pre></td></tr></table></figure><h3 id="outer-join">OUTER JOIN</h3><h4 id="left-outer-join">LEFT OUTER JOIN</h4><p>返回左表中所有行，以及右表中与其匹配的行，右表中若无匹配的行，则值为NULL</p><p>执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.Id <span class="hljs-operator">=</span> B.Id;<br></code></pre></td></tr></table></figure><p>得到</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">╔════╦═══════╦═════╦════════╗<br>║ Id ║ <span class="hljs-keyword">Value</span> ║ Id  ║  Name  ║<br>╠════╬═══════╬═════╬════════╣<br>║  <span class="hljs-number">1</span> ║    <span class="hljs-number">10</span> ║  <span class="hljs-number">1</span>  ║ Alice  ║<br>║  <span class="hljs-number">2</span> ║    <span class="hljs-number">20</span> ║  <span class="hljs-number">2</span>  ║ Bob    ║<br>║  <span class="hljs-number">3</span> ║    <span class="hljs-number">30</span> ║ <span class="hljs-keyword">NULL</span>║  <span class="hljs-keyword">NULL</span>  ║<br>╚════╩═══════╩═════╩════════╝<br></code></pre></td></tr></table></figure><h4 id="right-outer-join">RIGHT OUTER JOIN</h4><p>与LEFT OUTERJOIN同理，返回右表中所有行，以及左表中与其匹配的行，左表中若无匹配的行，则值为NULL。实际上只用LEFTOUTER JOIN就可以了</p><h4 id="full-outer-join">FULL OUTER JOIN</h4><p>返回左表和右表中所有行。如果没有匹配行，则值为 NULL</p><p>执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.Id <span class="hljs-operator">=</span> B.Id;<br></code></pre></td></tr></table></figure><p>得到</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">╔════╦═══════╦════╦════════╗<br>║ Id ║ <span class="hljs-keyword">Value</span> ║ Id ║  Name  ║<br>╠════╬═══════╬════╬════════╣<br>║  <span class="hljs-number">1</span> ║    <span class="hljs-number">10</span> ║  <span class="hljs-number">1</span> ║ Alice  ║<br>║  <span class="hljs-number">2</span> ║    <span class="hljs-number">20</span> ║  <span class="hljs-number">2</span> ║ Bob    ║<br>║  <span class="hljs-number">3</span> ║    <span class="hljs-number">30</span> ║<span class="hljs-keyword">NULL</span>║ <span class="hljs-keyword">NULL</span>   ║<br>║<span class="hljs-keyword">NULL</span>║  <span class="hljs-keyword">NULL</span> ║  <span class="hljs-number">3</span> ║ Carol  ║<br>╚════╩═══════╩════╩════════╝<br></code></pre></td></tr></table></figure><h1 id="表间关系">表间关系</h1><p>constraint为表添加关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CONSTRAINT</span> tableA <span class="hljs-keyword">PRIMARY</span> KEY(column1,column2,...)<br><span class="hljs-keyword">CONSTRAINT</span> childTable <span class="hljs-keyword">FOREIGN</span> KEY(column1,column2,...) <span class="hljs-keyword">REFERENCES</span> parentTable(column1,column2,...)<br></code></pre></td></tr></table></figure><h1 id="函数">函数</h1><p>或称为存储过程，一般格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> function_name (parameter1 data_type, parameter2 data_type, ...)<br>  <span class="hljs-keyword">RETURNS</span> return_type <span class="hljs-keyword">AS</span><br>$$<br><span class="hljs-keyword">DECLARE</span><br>  <span class="hljs-comment">-- 声明变量和其他局部对象</span><br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-comment">-- 函数体，包含实际的逻辑代码</span><br>  <span class="hljs-comment">-- 可以使用 SQL 语句和 PL/SQL 代码</span><br>  <span class="hljs-comment">-- 使用 RETURN 语句返回结果</span><br>  <span class="hljs-comment">-- 可以使用 EXCEPTION 子句处理异常</span><br><span class="hljs-keyword">END</span>;<br>$$<br><span class="hljs-keyword">LANGUAGE</span> plpgsql;<br></code></pre></td></tr></table></figure><h2 id="例">例</h2><p>采用PostgreSQL开发实现一个图书借阅管理系统数据库BookDB，该数据库包含部门信息表（DEPARTMENT）、读者信息表（READER）、图书信息表（BOOK）、借阅记录表（LOAN），其表结构定义如表2-17～表2-20所示。</p><p><img src="figure1.png" align="middle" width="60%"></p><p><img src="figure2.png" align="middle" width="60%"></p><p>创建数据库 testDB</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database testdb; <br></code></pre></td></tr></table></figure><p>创建表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> department(<br><br>    DeptId <span class="hljs-type">varchar</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">primary</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<span class="hljs-comment">--即使不写not null，主键也必须添加内容</span><br><br>    DeptName <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    DeptTel <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br><br>    DeptManager <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)<br><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> reader(<br><br>    readerId <span class="hljs-type">varchar</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">primary</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    readerName <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    gender <span class="hljs-type">varchar</span>(<span class="hljs-number">2</span>),<br><br>    birthday <span class="hljs-type">date</span>,<br><br>    deptid <span class="hljs-type">varchar</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">references</span> department(deptid),<span class="hljs-comment">--reader.deptid指定为外键，reader.deptid必须是department.deptid出现过的值</span><br>    phone <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>) <br><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> book(<br><br>    bookid SERIAL <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key,<span class="hljs-comment">--book.bookid指定为代理键。其意义为将自动编号类型作为主键</span><br><br>    isbn <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    bookname <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    bookintr <span class="hljs-type">varchar</span>(<span class="hljs-number">250</span>),<br><br>    booktype <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>),<br><br>    authors <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>),<br><br>    price money,<br><br>    publisher <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>),<br><br>    publidate <span class="hljs-type">date</span><br><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> loan(<br><br>    recordid SERIAL <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">constraint</span> rid <span class="hljs-keyword">primary</span> key,<br><br>    readerid <span class="hljs-type">varchar</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">references</span> reader(readerid),<br><br>    bookid <span class="hljs-type">bigint</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">references</span> book(bookid),<br><br>    opertype <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    operdate <span class="hljs-type">date</span>,<br><br>    note <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)<br>)<br></code></pre></td></tr></table></figure><p>在读者信息表中 增加一列 email varchar(30)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> reader <span class="hljs-keyword">add</span> email <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>在4个表上创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX deptname_index <span class="hljs-keyword">ON</span> department(deptname);<br><br><span class="hljs-keyword">CREATE</span> INDEX readername_index <span class="hljs-keyword">ON</span> reader(readername);<br><br><span class="hljs-keyword">CREATE</span> INDEX bookname_index <span class="hljs-keyword">ON</span> book(bookname);<br><br><span class="hljs-keyword">CREATE</span> INDEX recordid_index <span class="hljs-keyword">ON</span> loan(recordid);<br></code></pre></td></tr></table></figure><p>在表中各插入至少2行数据（请注意所有的约束条件）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> department(deptid,deptname,depttel) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;12&#x27;</span>,<span class="hljs-string">&#x27;计算机教研室&#x27;</span>,<span class="hljs-string">&#x27;1383838&#x27;</span>),(<span class="hljs-string">&#x27;03&#x27;</span>,<span class="hljs-string">&#x27;保卫科&#x27;</span>,<span class="hljs-string">&#x27;1233211&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> reader(readerid,readername,deptid) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;14&#x27;</span>,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-string">&#x27;12&#x27;</span>),(<span class="hljs-string">&#x27;06&#x27;</span>,<span class="hljs-string">&#x27;Mike&#x27;</span>,<span class="hljs-string">&#x27;12&#x27;</span>);  <span class="hljs-comment">--注意外键的值必须在主表出现</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(isbn,bookname) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;ISB111&#x27;</span>,<span class="hljs-string">&#x27;Embedding system&#x27;</span>),(<span class="hljs-string">&#x27;ISB222&#x27;</span>,<span class="hljs-string">&#x27;Database&#x27;</span>)<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> loan(readerid,bookid,opertype) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;14&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>),(<span class="hljs-string">&#x27;14&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>)<br></code></pre></td></tr></table></figure><p>修改 计算机教研室的部门负责人 为 ‘王帆帆’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> department <span class="hljs-keyword">SET</span> deptmanager<span class="hljs-operator">=</span><span class="hljs-string">&#x27;王帆帆&#x27;</span> <span class="hljs-keyword">WHERE</span> deptname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;计算机教研室&#x27;</span>;<br></code></pre></td></tr></table></figure><p>删除没有借书的读者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> loan <span class="hljs-keyword">WHERE</span> opertype<span class="hljs-operator">=</span><span class="hljs-string">&#x27;N&#x27;</span>;<br></code></pre></td></tr></table></figure><p>把商务出版社的书的价格都修改成九折。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> book <span class="hljs-keyword">SET</span> price<span class="hljs-operator">=</span><span class="hljs-number">0.9</span><span class="hljs-operator">*</span>price <span class="hljs-keyword">WHERE</span> publisher <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;商务出版社&#x27;</span>; <br></code></pre></td></tr></table></figure><p>查询借过‘数据库原理’书的读者的名字和部门</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> readername,deptname <span class="hljs-keyword">from</span> loan <br><br><span class="hljs-keyword">join</span> book <span class="hljs-keyword">on</span> loan.bookid<span class="hljs-operator">=</span>book.bookid<br><br><span class="hljs-keyword">join</span> reader <span class="hljs-keyword">on</span> reader.readerid<span class="hljs-operator">=</span>loan.readerid <br><br><span class="hljs-keyword">join</span> department <span class="hljs-keyword">on</span> department.deptid<span class="hljs-operator">=</span>reader.deptid <br><br><span class="hljs-keyword">where</span> bookname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;数据库原理&#x27;</span><br></code></pre></td></tr></table></figure><p>统计各个部门的读者数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptname,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> department <span class="hljs-keyword">join</span> reader <span class="hljs-keyword">on</span> department.deptid<span class="hljs-operator">=</span>reader.deptid <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptname<br></code></pre></td></tr></table></figure><p>查询至少借过5本以上书籍的读者编号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> reader.readerid,readername <span class="hljs-keyword">from</span> reader <span class="hljs-keyword">join</span> loan <span class="hljs-keyword">on</span> reader.readerid<span class="hljs-operator">=</span>loan.readerid<br><br><span class="hljs-keyword">where</span> opertype <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> opertype <span class="hljs-keyword">from</span> loan <span class="hljs-keyword">where</span> opertype<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Y&#x27;</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> opertype <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>查询出生在2000年的读者的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><br><span class="hljs-keyword">FROM</span> reader<br><br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">EXTRACT</span>(<span class="hljs-keyword">YEAR</span> <span class="hljs-keyword">FROM</span> birthday) <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><p>按照编号、姓名来统计每个人的借书的数量包括没有借过书的人员</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> reader.readerId, reader.readerName, <span class="hljs-built_in">COUNT</span>(loan.bookid) <span class="hljs-keyword">AS</span> num_borrowed<br><br><span class="hljs-keyword">FROM</span> reader<br><br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> loan <span class="hljs-keyword">ON</span> reader.readerId <span class="hljs-operator">=</span> loan.readerid<br><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> reader.readerId, reader.readerName;<br><span class="hljs-comment">--没有借书的loan.readerid=NULL,如果使用join则不会将其加入表中，因此使用left join返回左表reader中的全部列，与相匹配的loan中的列</span><br></code></pre></td></tr></table></figure><p>查询在最近一个月内借出的书的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><br><span class="hljs-keyword">FROM</span> loan<br><br><span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> loan.bookid <span class="hljs-operator">=</span> book.bookid<br><br><span class="hljs-keyword">WHERE</span> operdate <span class="hljs-operator">&gt;=</span> NOW() <span class="hljs-operator">-</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-string">&#x27;1 month&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询在最近一个月内借书的最多的读者的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> reader.<span class="hljs-operator">*</span>, <span class="hljs-built_in">COUNT</span>(loan.bookid) <span class="hljs-keyword">AS</span> num_borrowed<br><br><span class="hljs-keyword">FROM</span> reader<br><br><span class="hljs-keyword">JOIN</span> loan <span class="hljs-keyword">ON</span> reader.readerId <span class="hljs-operator">=</span> loan.readerid<br><br><span class="hljs-keyword">WHERE</span> operdate <span class="hljs-operator">&gt;=</span> NOW() <span class="hljs-operator">-</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-string">&#x27;1 month&#x27;</span><br><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> reader.readerId<br><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> num_borrowed <span class="hljs-keyword">DESC</span><br><br>LIMIT <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>把商务出版社的书的价格都修改成九折。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> book<br><br><span class="hljs-keyword">SET</span> price <span class="hljs-operator">=</span> price <span class="hljs-operator">*</span> <span class="hljs-number">0.9</span><br><br><span class="hljs-keyword">WHERE</span> publisher <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;商务出版社&#x27;</span>;<br></code></pre></td></tr></table></figure><p>创建一个视图 读者借书情况（读者编号， 读者信息，书的名称，书的出版时间， 借出的时间）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> reader_loan_info <span class="hljs-keyword">AS</span><br><br><span class="hljs-keyword">SELECT</span> r.readerid, r.readername <span class="hljs-keyword">AS</span> reader_info, b.bookname, b.publidate, l.operdate<br><br><span class="hljs-keyword">FROM</span> reader r<br><br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> loan l <span class="hljs-keyword">ON</span> r.readerid <span class="hljs-operator">=</span> l.readerid<br><br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book b <span class="hljs-keyword">ON</span> l.bookid <span class="hljs-operator">=</span> b.bookid;<br></code></pre></td></tr></table></figure><p>创建用户 user1， user2， 创建角色</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> user1;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> user2;<br><br><span class="hljs-keyword">CREATE</span> ROLE dept_reader;<br></code></pre></td></tr></table></figure><p>把部门信息表， 读者信息表的所有权限授予 user1 ， user2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">UPDATE</span>, <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> department, reader <span class="hljs-keyword">TO</span> user1, user2;<br><br><span class="hljs-keyword">GRANT</span> dept_reader <span class="hljs-keyword">TO</span> user1, user2;<br></code></pre></td></tr></table></figure><p>把图书信息表， 借阅信息表的插入、删除权限授给user1. user2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> book, loan <span class="hljs-keyword">TO</span> user1;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> book, loan <span class="hljs-keyword">TO</span> user2;<br></code></pre></td></tr></table></figure><p>把部门信息表， 读者信息表的修改、删除权限从user1 收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">UPDATE</span>, <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> department, reader <span class="hljs-keyword">FROM</span> user1;<br></code></pre></td></tr></table></figure><p>把图书信息表修改、删除权限从user1 收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">UPDATE</span>, <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> book <span class="hljs-keyword">FROM</span> user1;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> goods (<br>  goodid SERIAL <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key,<br>  goodname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  type <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>  price <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customers (<br>  custid SERIAL <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key,<br>  custname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  address <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>  telphone <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>  orderid SERIAL <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key,<br>  orderdate <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  goodid <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  custid <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  pruchnum <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  status <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;未支付&#x27;</span>,<br>  <span class="hljs-keyword">FOREIGN</span> KEY (goodid) <span class="hljs-keyword">REFERENCES</span> goods(goodid),<br>  <span class="hljs-keyword">FOREIGN</span> KEY (custid) <span class="hljs-keyword">REFERENCES</span> customers(custid)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> stocks (<br>  goodid <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>  storenum <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  storeplace <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>  <span class="hljs-keyword">FOREIGN</span> KEY (goodid) <span class="hljs-keyword">REFERENCES</span> goods(goodid)<br>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> goods (goodname, type, price) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;苹果&#x27;</span>, <span class="hljs-string">&#x27;水果&#x27;</span>, <span class="hljs-number">5.0</span>),<br>(<span class="hljs-string">&#x27;香蕉&#x27;</span>, <span class="hljs-string">&#x27;水果&#x27;</span>, <span class="hljs-number">3.5</span>),<br>(<span class="hljs-string">&#x27;牛奶&#x27;</span>, <span class="hljs-string">&#x27;乳制品&#x27;</span>, <span class="hljs-number">12.0</span>),<br>(<span class="hljs-string">&#x27;鸡蛋&#x27;</span>, <span class="hljs-string">&#x27;禽蛋&#x27;</span>, <span class="hljs-number">2.5</span>),<br>(<span class="hljs-string">&#x27;面包&#x27;</span>, <span class="hljs-string">&#x27;烘焙&#x27;</span>, <span class="hljs-number">4.0</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers (custname, address, telphone) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;北京市朝阳区&#x27;</span>, <span class="hljs-string">&#x27;13812345678&#x27;</span>),<br>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;上海市浦东新区&#x27;</span>, <span class="hljs-string">&#x27;13987654321&#x27;</span>),<br>(<span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;广州市天河区&#x27;</span>, <span class="hljs-string">&#x27;13611112222&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> stocks (goodid, storenum, storeplace) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;A仓库&#x27;</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;B仓库&#x27;</span>),<br>(<span class="hljs-number">3</span>, <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;C仓库&#x27;</span>),<br>(<span class="hljs-number">4</span>, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;D仓库&#x27;</span>),<br>(<span class="hljs-number">5</span>, <span class="hljs-number">300</span>, <span class="hljs-string">&#x27;E仓库&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (orderdate, goodid, custid, pruchnum, status) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;2023-04-20&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;未支付&#x27;</span>),<br>(<span class="hljs-string">&#x27;2023-04-21&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;已支付&#x27;</span>),<br>(<span class="hljs-string">&#x27;2023-04-22&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;未支付&#x27;</span>),<br>(<span class="hljs-string">&#x27;2023-04-23&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;未支付&#x27;</span>),<br>(<span class="hljs-string">&#x27;2023-04-24&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;已支付&#x27;</span>);<br><br><span class="hljs-comment">-- 1. 统计给定日期的销售额</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> sumdaysales(sdate <span class="hljs-type">DATE</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">NUMERIC</span> <span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">DECLARE</span> <br>allmoney <span class="hljs-type">NUMERIC</span>;<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(pruchnum<span class="hljs-operator">*</span>price) <span class="hljs-keyword">INTO</span> allmoney<br>    <span class="hljs-keyword">FROM</span> orders o <span class="hljs-keyword">JOIN</span> goods g <span class="hljs-keyword">ON</span> o.goodid <span class="hljs-operator">=</span> g.goodid <br>    <span class="hljs-keyword">WHERE</span> orderdate <span class="hljs-operator">=</span> sdate;<br><span class="hljs-keyword">RETURN</span> allmoney;<br><span class="hljs-keyword">END</span>;<br>$$ <span class="hljs-keyword">LANGUAGE</span> plpgsql;<br><br><span class="hljs-keyword">SELECT</span> sumdaysales(<span class="hljs-string">&#x27;2023-04-22&#x27;</span>);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>SQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C</title>
    <link href="/2022/03/31/C/"/>
    <url>/2022/03/31/C/</url>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="运算符">运算符</h1><h2 id="自增">自增</h2><p>i++与++i的区别在于：i++是i的值在引用后自增，++i是i的值在引用前自增；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int j,<span class="hljs-attribute">i</span>=1;<br>i++;\本条语句结束后，<span class="hljs-attribute">i</span>=2`<br>++j；\\本条语句执行前，<span class="hljs-attribute">j</span>=2<br>printf(<span class="hljs-string">&quot;%d\t%d&quot;</span>,i++,++j);\\本条语句执行前，<span class="hljs-attribute">j</span>=3；本条语句结束后，i=3；因此结果为23<br>printf(<span class="hljs-string">&quot;%d\t%d&quot;</span>,i,j);\\结果为33<br></code></pre></td></tr></table></figure><p>形如(++i)++的语句是错误的，因为执行自增自减的必须是变量，而++i是常量；</p><p><code>char c[]="U"; char *x=c;  if(*x++) printf("aaa");</code></p><p>例如上面这段代码输出aaa，因为是先执行判断语句，x再进行自增；</p><p>如果改成下面这样：</p><p><code>char c[]="U"; char *x=c;  if(*++x) printf("aaa");</code></p><p>就不会输出aaa，因为是先进行自增，再执行判断语句；</p><ul><li>后缀++的优先级高于前缀++和<em>，</em>与前缀++都为2级，且为右结合，所以 <em>++x相当于 </em>(++x);</li></ul><p>sizeof运算符</p><p>sizeof运算符可以应用于常量，变量，表达式，用来计算该类型的字节数；sizeof（数组名）表示该数组所有元素字节数之和，sizeof（数组名）/sizeof（数组首元素）即为数组元素个数；</p><p>`int main(){ <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(i));<span class="hljs-comment">//print 4;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(i+j));<span class="hljs-comment">//print 4;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">//print 40;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]));<span class="hljs-comment">//print 10;</span><br>&#125;`<br></code></pre></td></tr></table></figure></p><p>sizeof运算符属于size_t类型，是一种无符号整型；</p><h1 id="循环">循环</h1><h2 id="continue语句与break语句">continue语句与break语句</h2><p>continue跳到循环的末端，没有跳出该层循环；break跳出该层循环；</p><h2 id="goto语句">goto语句</h2><p>goto语句可以跳到函数中任何有标号的语句处；goto语句往往可以被break，continue，return语句，exit函数代替，有用的地方是：在switch语句中可以跳出循环，在嵌套循环中可以跳到任何地方；</p><h1 id="数组">数组</h1><p>数组是固定长度的，任何类型的数组都需要先声明长度，也就是初始化；这也产生了一个问题：如果想把输入的值存储到数组中，那么无法确定数组的长度；要解决这一问题，就要用到链表；</p><h1 id="基本类型">基本类型</h1><p>基本类型包括：</p><ul><li>整型，即整数类型，值为整数，包括整型int(二进制32位，4字节（Byte），一个字节等于二进制八位（bits）)，长整型longint（8字节），短整型short int（2字节）</li><li>浮点型，其值可以有小数部分，包括单精度浮点型float（4字节），双精度浮点型double（8字节），扩展精度浮点型longdouble；</li><li>浮点型数要写出小数点，并在最后加上f，在整型和浮点型数没有本质区别时不加也可以，比如<code>float a=1;</code>a的值为1.000000；但是计算除法时，比如<code>float a=2/3;</code>和<code>float a=2.0f/3.0f;</code>就不同了，前者a是0.000000，后者a是0.666667。</li></ul><h2 id="变量与类型">变量与类型</h2><p>声明为某种类型的变量，必须将它赋以相同类型的值，不过，浮点型的变量可以赋以整型的值，比如<code>float a=2\\a的值为2.000000</code>，但是这在除法中就不会达到期望的效果，比如：</p><p><code>float a;     int b=2,c=3;     a=b/c;     printf("%f",a);</code></p><p>输出的是0.000000，因为b，c都是整型，先执行除法运算，两个整型的除法结果还是整型，因此a被赋予0；从这个例子可以明白，变量的类型并不影响它被赋给的值的类型，可以把被赋值的变量当成某种形状的容器，向里面加入什么东西，并不会因为它的形状改变；</p><h2 id="强制类型转换">强制类型转换</h2><p>上面的例子中，将<code>a=b/c</code>改成<code>a=(float)b/c</code>，即可将b/c转换为浮点型；</p><h2 id="转换说明与转义序列">转换说明与转义序列</h2><p>​转换说明可以用<code>%m.pX</code>或<code>%-m.pX</code>表示，其中m，p是数字，选择写或不写，X是字母，必写。第一种是右对齐，第二种是左对齐，m的值代表至少占用m个字符的空间；p的值代表至少有p位有效数字；</p><h2 id="typedef类型声明">typedef类型声明</h2><p>typedef可以把变量名声明为一种类型，这个变量名可以作为类型声明其他变量，比如：</p><p><code>typedef int *p; int f(p m) &#123;     printf("%d",*m); &#125; int main() &#123;     int *i;     scanf("%d",i);     f(i);     return 0; &#125;</code></p><p>这里p代表整型指针，在函数f()中形参m就是p类型的变量，也就是整型指针，因此调用函数f()时传入整型指针i。</p><h2 id="字符型">字符型</h2><p>char类型的变量可以用任意单字符赋值，例如</p><p><code>char ch;</code></p><p><code>ch='a';</code></p><ul><li><p>字符常量需要用单引号括起来；</p></li><li><p>字符型实际上是一个字符而非字符串；</p></li></ul><h2 id="字符操作">字符操作</h2><p>c语言把字符当做小整数进行处理，在ASCII码中字符的取值范围是00000000（即0）—11111111（即127）的整数，字符'a'的值为97,</p><p>'A'的值为65，同样可对字符进行运算，例如</p><p><code>int i;</code></p><p><code>char ch;</code></p><p><code>i='a';//i is now 97,depending on the type of i;</code></p><p><code>ch=65;//ch is now 'A'</code></p><p><code>ch++;//ch is now 'B'</code></p><p>字符可以进行比较，例如下面这段程序测试ch是否为小写字母，如果是，将其转换为大写字母</p><p><code>if('a'&lt;=ch&amp;&amp;ch&lt;='z')</code></p><p><code>ch=ch-'a'+'A';</code></p><h2 id="getchar函数读取单个字符">getchar函数（读取单个字符）</h2><p>scanf函数可以读取任何类型，但是在读取字符型时存在问题：scanf函数终止于空白字符，例如：</p><p><code>scanf("%s",str);</code></p><p><code>printf("%s",str);</code></p><p>输入a b c，输出a；</p><p>利用getchar()读取单个字符，可以避免这种问题；</p><h2 id="字符串">字符串</h2><p>字符串实际上是一个字符型的一维数组；</p><h3 id="字符数组与字符指针">字符数组与字符指针</h3><p>比较以下两个声明：</p><p><code>char date[]="June 14";</code></p><p><code>char *date="June 14;"</code></p><p>第一个声明a是一个数组，第二个声明a是一个指针，需要注意：</p><ul><li>在声明为数组时，就像任何数组中的元素一样，可以修改date中存储的字符，而声明为指针时，date指向字面串，是不能修改的；</li><li>在声明为数组时，date是数组名，在声明为指针时，date是指针变量，也可以指向其他字符串；</li></ul><h3 id="string.h头文件">&lt;string.h&gt;头文件</h3><h4 id="strcpy函数字符串复制">strcpy函数（字符串复制）</h4><p>原型为char <em>strcpy（char </em>s1,const char*s2）;strcpy把s2指向的字符串复制到s1指向的数组中，并返回s1，这一过程不会改变s2指向的字符串，因此将其声明为const；</p><ul><li>strcpy函数弥补了不能使用赋值运算符赋值字符串的不足，例如，假设我们想把字符串“abcd”复制存储到str中，不能使用下面的赋值：</li></ul><p><code>str="abcd";//wrong</code></p><p>这时应使用strcpy函数：</p><p><code>strcpy(str,"abcd");//数组名是指向该数组的指针</code></p><ul><li>上述操作中调用strcpy函数并未考虑字符串的大小是否不大于str指向的数组</li></ul><h4 id="strlen函数求字符串长度">strlen函数（求字符串长度）</h4><p>原型为size_t(const char*s);strlen函数返回字符串第一个空字符之前的字符个数（不包含空字符）；</p><p><code>printf("%d\n",strlen("a bcdefg"));     printf("%d\n",strlen("\0"));     printf("%d\n",strlen(""));</code></p><p>分别输出8，0，0；注意空字符('\0')和空格不同，空格也是一个字符；</p><h4 id="strcat函数字符串拼接">strcat函数（字符串拼接）</h4><p>原型为char <em>strcat(char </em>s1,const char*s2);把字符串s2的内容追加到s1的末尾并返回字符串s1；</p><p><code>strcat(str1,"abc");</code></p><p><code>strcat(str1,"def");//str1 now contains "abcdef"</code></p><ul><li>如果str1指向的数组没有大到足以容纳目标字符串，则会造成错误，比如：</li></ul><p><code>char str1[6]="abc";</code></p><p><code>strcat(str1,"def);//wrong</code></p><p>因为strcat把d，e，f，\0四个字符添加到str1中，超出str1的容量；</p><h4 id="strcmp函数字符串比较">strcmp函数（字符串比较）</h4><p>strcmp函数原型为int strcmp(const char <em>s1,const char</em>s2);strcmp函数比较s1与s2的长度，若s1&lt;s2,返回一个小于0的数；若s1&gt;s2，返回一个大于0的数；若s1==s2,返回0；</p><ul><li>只要满足下列任一条件，strcmp函数就返回小于0的数：</li></ul><ol type="1"><li>s1与s2前i个字符相同，但s1第i+1个字符的数值小于s2;</li><li>s1的所有字符与s2一致，但s1比s2短；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">char</span> *s,<span class="hljs-type">char</span> t)</span>&#123;<br><span class="hljs-keyword">while</span>(s&amp;&amp;t&amp;&amp;s==*t)&#123;<span class="hljs-comment">//==的优先级高 </span><br>s++;<br>t++;<br>&#125;<br><span class="hljs-keyword">return</span> s-t;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="enum枚举类型">enum枚举类型</h2><p>枚举类型可以让代码更简洁，其形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span>　枚举类型　&#123;</span>枚举元素<span class="hljs-number">1</span>,枚举元素<span class="hljs-number">2</span>,……&#125;变量名;<br></code></pre></td></tr></table></figure><p>比如下面这段示例，DAY是枚举类型，day是枚举型变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DAY</span></span><br><span class="hljs-class">&#123;</span><br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>DAY day;<br>day=WED;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,day);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数">函数</h1><p>函数关系是对每个自变量都有唯一的因变量与之对应，c语言中也有类似的函数：对于每一个输入的量，都有一个返回的量与之对应，比如：</p><p><code>int average(int a,int b)&#123;</code></p><p><code>int m;</code></p><p><code>m=(a+b)/2;</code></p><p><code>return m;&#125;</code></p><p>返回a，b的平均值。</p><p>对于更广义的函数，它不一定要有输入值甚至返回值，这时它的意义就是执行函数体内的语句，比如</p><p><code>void a()&#123;     printf("1"); &#125; int main() &#123;a(); return 0;&#125;</code></p><p>输出1；</p><ul><li><p>这里注意虽然a没有输入值，但是调用时仍然要写成a（void）或a（），不然编译器是不能识别的；</p></li><li><p>虽然a（）没有返回值但是还是输出了1，返回值是返回该函数类型的值，而输出值不一定是函数的返回值，也可能是执行函数体中的语句；</p></li></ul><h2 id="参数">参数</h2><h3 id="形式参数">形式参数</h3><p>出现在函数定义中，用来表示函数调用时所要提供的值，并没有实际意义</p><h3 id="实际参数">实际参数</h3><p>出现在函数调用中的表达式称为<strong>实际参数</strong>；实际参数是<strong>值传递</strong>的：先将实际参数的值赋给形式参数，然后形式参数在函数中执行相应语句，在函数执行过程中，对形式参数的改变不会影响实际参数的值，因此值传递被称为<strong>单向传递（即只能由实参传递给形参）</strong>，实参变量和形参变量分别占用不同的存储单元；c语言的这一特点有利有弊：</p><ul><li>因为形参的修改不会影响实参，所以可以把形参作为函数中的变量使用，这样可以减少真正需要的变量数量，例如：</li></ul><p><code>int power(int x,int n)&#123;     int result=1;int i;     for(i=0;i&lt;n;i++)     result*=x;     return result; &#125;</code></p><p>power函数计算了x的n次方，因为n是实参的副本，所以可以在函数体内修改它，也就不需要使用变量i了；</p><p><code>int power(int x,int n)&#123;     int result=1;     while(n-- &gt;0)     result*=x;     return result; &#125;</code></p><ul><li>c语言中函数不能返回两个值，如果想把两个变量传递给函数并对他们执行相应语句，比如将一个数分解为整数部分和小数部分，尝试以下程序：<code>void decompose(double x,long int_part,double frac_part)&#123;</code></li></ul><p><code>int_part=(long) x;</code></p><p><code>frac_part=x-int_part;&#125;</code></p><p>调用这个函数：<code>decompose(3.14,i,d);</code>我们希望i和d为整数部分和小数部分，但是i和d的值并不会发生变化，这就是因为形参不能传递给实参；要想解决这个问题，就要使用指针传递方式；</p><h4 id="数组型实际参数">数组型实际参数</h4><p>数组作为形式参数，当形式参数为一维数组时,可以不说明数组的长度，实际参数可以是元素类型正确的任何一维数组；</p><h2 id="一般格式">一般格式</h2><p>返回类型 函数名 （形式参数）｛复合语句｝</p><ul><li>返回类型即为函数返回值的类型,如果为void类型，说明函数没有返回值</li><li>函数不能返回数组，数组是数据结构，不是数据类型</li></ul><h2 id="return语句">return语句</h2><p>非void的函数必须使用return语句来指定将要返回的值，这个值的类型即函数类型；return语句后也可以跟表达式；void函数中return后可以无表达式，函数立刻返回，不再执行接下来的语句。</p><h1 id="程序结构">程序结构</h1><h2 id="局部变量">局部变量</h2><p>在函数体内声明的变量称为局部变量；局部变量作用效果只在该函数之内（作用域为块作用域），因此其他函数也可以将同名变量用于其他用途。</p><h4 id="存储期">存储期</h4><p>程序执行时变量的值保持不变（变量的存储空间存在）的时间称为存储期。局部变量的存储空间在函数被调用时自动分配的，在函数返回时收回分配，所以被称为<strong>自动存储期</strong>。</p><p>我们也可以使局部变量在整个程序执行期间都保持不变，在声明前加上static，称为具有<strong>静态存储期</strong>，例如<code>void f(void)&#123;static int i;&#125;</code>在函数f执行时i的值保持不变。（i仍然具有块作用域，其他函数中也可以使用i，与函数f无关）</p><h4 id="外部变量">外部变量</h4><p>声明在函数体外，函数可以对外部变量进行修改；</p><p><code>int i=0; void f(void) &#123;     i=1; &#125; int main() &#123;     f();     printf("%d",i);     return 0; &#125;</code></p><p>输出1；</p><ul><li>需要注意，不应在不同的函数中因为不同的目的使用外部变量，容易造成错误；</li></ul><h4 id="栈">栈</h4><p>栈是一种<strong>数据结构</strong>，字面解释成存放数据的房子，栈存放数据的方式可以当成：把书放到箱子里，先放进去的压箱底最后才能拿出来，最后放进去的最先拿出来。向栈中加入元素，只能从栈顶添加；取出元素同理；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">栈的存储机制是只能从一端出入，相当于一个入口的单行道，先进去的只有等后进去的出来后才能出来，也就是先进后出机制。<br>所以元素54321依次入栈，依次出栈的顺序就是12345<br></code></pre></td></tr></table></figure><ul><li>实现栈的方法之一：用数组来实现栈，构建一个数组和一个变量top，数组存储栈中的元素，top表示栈顶的位置（即最后一次加入数据时数组中项的序号），当栈为空时top=0（即top在数组的第一项a[0]）；将数据从栈中排出，只要让top-1；访问栈顶元素的值，直接返回top指向的值；栈里元素的个数，就是top的值；</li></ul><p>栈有四个功能：</p><ul><li><p>入栈（push）</p></li><li><p>判断栈满（isFull）</p></li><li><p>出栈（pop）</p></li><li><p>判断栈空（isEmpty）栈是一个操作受限的线性表，而线性表呢，主要有两种：</p><ol type="1"><li><p>顺序存储的数组 优点：操作简单，节省空间缺点：栈的大小一开始就声明死了，不利于使用</p></li><li><p>非顺序存储的链表 优缺点和顺序存储数组恰恰相反</p></li></ol></li></ul><h2 id="构建c程序">构建C程序</h2><p>C程序的构成要素：</p><ul><li><p>预处理指令</p></li><li><p>类型定义</p></li><li><p>全局变量的声明</p></li><li><p>除main函数外其他函数原型</p></li><li><p>main函数定义</p></li><li><p>除main函数外其他函数的定义</p></li><li><p>注释：函数的意义；参数的意义；如果函数有返回值，应给出描述信息；函数的副作用。</p></li></ul><h1 id="指针">指针</h1><h2 id="内存地址">内存地址</h2><p>内存中的每一个字节都拥有一个编号，称为内存地址（32位或64位，与处理器有关）；</p><p>变量的地址为第一个字节的地址；</p><h2 id="指针变量">指针变量</h2><p>定义一个变量存放内存地址，称为指针变量；</p><p>例如<code>int num=100;</code>系统根据num的类型（int，4字节）开辟一个内存空间，每一个字节都有一个地址，num的地址为第一个字节的地址。</p><h3 id="声明指针变量">声明指针变量</h3><p>声明指针变量p指向某种类型对象，比如<code>int *p;</code>每个指针变量只指向一种类型的对象，比如<code>char*m；</code>表示m指向一个字符型变量；</p><p>声明指针变量时，为指针留出空间，但未将其指向任何对象；初始化的一个方法就是用某个变量的地址对其赋值；例如inti，*p=&amp;i；</p><h3 id="取址运算符">取址运算符</h3><p>&amp;为取址运算符，用于得到变量的地址；例如int*p=&amp;a；指针变量p存放a的地址；</p><h3 id="寻址运算符">寻址运算符</h3><p>​ *为寻址运算符，用于访问指针指向的对象的内容；如果p指向i，则<em>p与i等价，改变</em>p的值也会改变i的值。例如j=<em>&amp;i；即先取i的地址再访问&amp;i,等价于j=i。注意这里的</em>与定义指针变量的相同，但二者意义不同，属于是符号的重复使用；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">3</span>,b=<span class="hljs-number">4</span>,p,m=&amp;b;<span class="hljs-comment">//这里为声明指针变量</span><br>p=&amp;a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n%d\n%d\n%d\n&quot;</span>,p,p,m,m);<span class="hljs-comment">//这里为寻址</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p>例如这段程序输出值分别为...(a地址)，3（a的值），...（b地址），4（b的值）</p><ul><li>如果指针变量未初始化，则用寻址运算符无意义，<code>如int *p；printf（“%d”，*p）；</code>是无意义的；</li></ul><h3 id="指针赋值">指针赋值</h3><p>如果p，q都指向i，无论对* p，* q赋值，* p，*q，i等价变化，因为他们都代表同一对象；在函数中形参如果是指针，那么实参与其副本形参都指向同一个地址中的值，也就实现了“修改实参的值”的效果；</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">decompose</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">long</span> *int_part,<span class="hljs-type">double</span> *frac_part)</span>&#123;<br>*int_part=(<span class="hljs-type">long</span>) x;<br>*frac_part=x-*int_part;&#125;<br></code></pre></td></tr></table></figure><p>指针变量int_part和frac_part分别存储了x整数部分和小数部分的地址，地址不会改变，因此对应的元素能逃出函数范围；</p><p>再看一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<span class="hljs-comment">//x,y是形式参数</span><br><span class="hljs-type">int</span> t;<br><span class="hljs-keyword">if</span>(x&gt;y)<br>&#123;<br>t=x;<br>x=y;<br>y=t;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>i=<span class="hljs-number">1</span>;j=<span class="hljs-number">2</span>;<br>swap(j,i);<span class="hljs-comment">//i，j是实际参数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,i,j);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望调用swap实现将i，j的值交换，但是失败了；再来看这段话：出现在函数调用中的表达式称为<strong>实际参数</strong>；实际参数是<strong>值传递</strong>的：先将实际参数的值赋给函数的形式参数，然后形式参数在函数中执行相应语句，在函数执行过程中，对形式参数的改变不会影响实际参数的值，因此值传递被称为<strong>单向传递（即只能由实参传递给形参）</strong>，实参变量和形参变量分别占用不同的<strong>存储单元</strong>；还要注意，指针作为形参仍然遵循相同的规则，也是由实参（这里是指针）赋值给形参，然后形参在函数体内执行相应语句，之所以说指针形参能修改实参，是因为指针实参与相应的指针形参指向同一对象，然后指针形参在函数内对所指对象进行操作（称为<strong>解引用</strong>），也就实现了修改实参的效果；从这里我们也能理解，函数要想修改实际参数，必须<strong>有两个过程</strong>：</p><ul><li><strong>将指针实际参数传递给指针形式参数，</strong>以便在函数体内执行操作；（传参）</li><li><strong>指针形式参数在函数体内必须对其所指对象进行操作，以修改对象的值，</strong>否则在函数结束时，指针形式参数与普通形式参数一样会消失，并不能保留指针形参的相应变化；（解引用）</li></ul><p><code>int swap(int *x,int *y)&#123;//传参     int t;         t=*x;         *x=*y;         *y=t;//解引用 &#125;</code></p><p>这是正确的swap函数；而下面的例子：</p><p><code>int swap(int *x,int *y)&#123;     int *t;         *t=*x;         *x=*y;         *y=*t; &#125;</code></p><p>虽然也符合以上两条件，但是却违背了基本规则：指针必须初始化；</p><h2 id="指针与数组">指针与数组</h2><p>数组名的地址就是数组第一个元素的地址，例如这段程序，两次输出结果相同。</p><p><code>int main()&#123;</code></p><p><code>char str[128];</code></p><p><code>printf（"%p",str）;</code></p><p><code>printf("%p",&amp;str[0]);//这里取str[0]的地址，用&amp;</code></p><p><code>return 0;&#125;</code></p><p>数组中每两个相邻元素的地址值的差相等，等于该类型的字节数；</p><p><code>int main()&#123;     char a[]="haha";     int b[]=&#123;1,2,3&#125;;     float c[]=&#123;1,2,3&#125;;     double d[]=&#123;1,2,3&#125;;     printf("%p %p %p\n",&amp;a[0],&amp;a[1],&amp;a[2]);     printf("%p %p %p\n",&amp;b[0],&amp;b[1],&amp;b[2]);     printf("%p %p %p\n",&amp;c[0],&amp;c[1],&amp;c[2]);     printf("%p %p %p\n",&amp;d[0],&amp;d[1],&amp;d[2]);     return 0; &#125;</code></p><p>上面这段程序两两之差分别为1，2，4，8，对应四种类型的字节数（地址的值为十六进制）；因此，指向数组的指针的加减等于相应地址的加减，又对应数组中的元素；</p><p><code>int main()&#123; int a[]=&#123;1,2,3&#125;;     int *p=a;     printf("%d %d %d",*p,*(p+1),*(p+2));     return 0; &#125;</code></p><p>例如上面这段代码，输出的值分别为1，2，3，注意<em>（p+1）不是将地址+1，而是指向数组下一个元素；（</em>p+1表示*p与1之和，即第一个元素与1之和，如果其为字符型则会出错）；</p><p>c语言只有3种格式的指针算数运算：指针加整数；指针减整数；指针减指针；</p><ol type="1"><li>如果p指向数组元素a[i],那么p+j指向a[i+j];</li><li>两个指针相减，结果为指针之间的距离（用数组元素的个数来度量），如果p指向a[i],q指向a[j]，那么p-q=i-j；</li><li>指针的比较：可以用关系运算符（&lt;,&gt;,&lt;=,&gt;=）和判等运算符（==，！=）进行指针比较，只有当两个指针指向同一数组时比较才有意义，比较的结果依据数组中两个元素的相对位置，例如在下面的赋值中p&gt;=q的结果为1：</li></ol><p><code>p=&amp;a[5];</code></p><p><code>q=&amp;a[1];</code></p><p>来看下面这段代码：</p><p><code>int i,*p,a[]=&#123;1,2,3,4,5&#125;; p=&amp;a[1]; for(i=0;i&lt;5;i++) printf("%d",p[i]);\\结果是23450，因为p数组只被赋给了4个元素   return 0;</code></p><p>我们并没有把p声明为数组，但是却能输出p[i]，实际上，[]应该称为下标运算符，它对一个地址进行取下标操作，比如p[1]，代表p指向的地址加上p的类型的字节数；</p><h3 id="指针数组">指针数组</h3><ul><li>指针可以指向数组中的元素，但是数组名是一个地址，属于常量，给数组名赋值的操作是错误的，比如：</li></ul><p><code>char str1[10],str2[10];</code></p><p><code>str1="abc"//wrong;</code></p><p><code>str2=str1;//wrong</code></p><p>但是在数组初始化中，=不是赋值运算符；</p><p>而指针是左值，可以进行赋值和自增；</p><ul><li>指针数组是一个数组，每个数组元素存放一个指针变量，可以表示为int*p1[]；在下面的例子中，hello，world都相当于一维数组，</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p1[]=&#123;<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,p1[i]);<span class="hljs-comment">//%s表示输出字符串 </span><br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>需要注意，c语言中并没有字符串类型，字符串其实是一组一维数组，也就是各个字符组成的数组，因为hello相当于是数组（当成</p><p>chara[]=｛“h”，“e”，“l”，“l”，“o”｝），所以如果再加一个*，就是取a[0]这个地址中存放的值，也就是h（同时要将%s换成%c）；</p><h3 id="数组指针">数组指针</h3><p>数组指针是指向数组的指针，需要注意数组的地址等于数组名的地址，但不相同；数组名的地址也就是数组第一个元素的地址，而整个数组另有一个地址，这个地址与数组名的地址相等，例如下面这个打印数组元素的程序：</p><p><code>int main()&#123;     int temp[]=&#123;1,2,3&#125;;     int (*p)[3]=&amp;temp;//取数组temp的地址，将其存放在变量p中     int i;     for(i=0;i&lt;3;i++)         printf("%d\n",*(*p+i));//*p表示数组temp第一个元素的地址，再对其寻址得到元素值         return 0; &#125;</code></p><p>从这个例子可以看出，指针也可以存放地址；例如<code>int *p=&amp;q；int *q=&amp;j；</code>那么*p等于q(等于&amp;j，) **p等于 *q等于j；</p><h3 id="指针与二维数组">指针与二维数组</h3><p>如果int array[4] [5]，则array的值为array[0][0]的地址，array+1的值为array[1][0]的地址，因为二维数组在内存中是线性排列的，对于一维数组而言，数组中元素地址顺序依次排列，因此数组名+1即为数组最后一个元素地址后的那个地址（两者间隔为该类型的字节数）；二维数组在内存中是每一行的元素依次排列的，因此数组名+1即为数组第二行的第一个元素的地址；</p><h2 id="空指针">空指针</h2><p>空指针是不指向任何地方的指针，用名为NULL的宏表示，这是一个区别于有效指针的特殊值；NULL的地址为0，因此if（NULL）相当于if（0）；</p><h2 id="动态内存分配">动态内存分配</h2><p>为了动态地分配存储空间，需要调用内存分配函数；这些函数声明在&lt;stdlib.h&gt;头文件(standardlibrary，标准库头文件）中；</p><h3 id="malloc函数">malloc函数</h3><p>原型：<code>void *malloc（size_t  size）;malloc</code>函数让系统分配size个字节的内存空间，并返回一个指向这块空间的指针，但是并不对内存进行初始化；</p><ul><li>由于返回类型是void，所以它可以被转换成任何类型的数据，如果函数调用失败，返回值是NULL，如果size参数设置为0，返回值也可能是NULL；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> *p;<br>p=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//malloc返回任意类型，因此最好加上强制类型转换；</span><br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fault&quot;</span>);exit（<span class="hljs-number">1</span>）；&#125;<span class="hljs-comment">//如果找不到我们需要的足够大的内存块，就会返回NULL；一般不存在这种问题printf(&quot;enter an interger:&quot;);</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;what you enter is:%d&quot;</span>,p);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，直接对p进行赋值是错误的，例如</p><p><code>int *p;     scanf("%d",p);      printf("%d",*p);</code></p><p>并不能输出我们想要的值，因为并未声明p指向什么，即未初始化；指针必须初始化；</p><h3 id="释放内存空间">释放内存空间</h3><p>申请的动态内存如果未释放，则这块内存空间一直存在，直到程序被关闭；如果一段申请动态内存的代码在循环中，不释放内存会导致内存被耗尽；我们使用free函数释放内存空间；</p><p>原型：void free(void *ptr)；</p><p>free函数释放ptr参数指向的内存空间，该内存空间必须是由以上三种函数申请的，否则导致未定义；该函数并不修改ptr的值，所以调用后仍然指向原来的地方（和预期不同）；</p><p>因此，我们修改上述代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> p;<br>p=(<span class="hljs-type">int</span>)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//malloc返回任意类型，因此最好加上强制类型转换；</span><br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fault&quot;</span>);exit（<span class="hljs-number">1</span>）；<br>&#125;<span class="hljs-comment">//如果找不到我们需要的足够大的内存块，就会返回NULL；一般不存在这种问题</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter an interger:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;what you enter is:%d&quot;</span>,*p);`<br><span class="hljs-built_in">free</span>(p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;what you enter is:%d&quot;</span>,*p);<span class="hljs-comment">//这里的值不是我们输入的值，因为内存被释放</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内存泄露">内存泄露</h3><p>内存泄露有两种，上面是一种（隐式内存泄漏），另一种如下（丢失内存块地址）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> p;<br><span class="hljs-type">int</span> num=<span class="hljs-number">123</span>;<br>p=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//malloc返回任意类型，因此最好加上强制类型转换；</span><br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fault&quot;</span>);exit（<span class="hljs-number">1</span>）；<br>&#125;<span class="hljs-comment">//如果找不到我们需要的足够大的内存块，就会返回NULL；一般不存在这种问题</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter an interger:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p);<br>p=<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;what you enter is:%d&quot;</span>,*p);`<br><span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出123；程序无视了输入，因为malloc申请的内存块的地址保存在p中，也就是说只有p知道这个地址，现在给p赋新值，那这个地址就丢失了；更严重的是，p=&amp;num执行后p是局部变量的指针，free（p）会导致错误；</p><h3 id="calloc函数">calloc函数</h3><p>malloc函数不能初始化内存空间，使用calloc函数可对内存进行初始化，其原型为：void*calloc（size_t n,size_tsize）;calloc函数为n个元素的数组分配内存空间，每个元素的长度都为size个字节，类似malloc函数，如果要求的空间无效，则返回NULL；在分配内存后，calloc函数把所有元素初始化为0；</p><h1 id="结构体">结构体</h1><p>数组（Array），它是一组具有相同类型的数据的集合。但在实际的编程过程中，我们往往还需要一组类型不同的数据，例如对于学生信息登记表，姓名为字符串，学号为整数，年龄为整数，所在的学习小组为字符，成绩为小数，因为数据类型不同，显然不能用一个数组来存放。</p><p>在C语言中，可以使用 结构体（<code>Struct</code>）来存放一组不同类型的数据。结构体的定义形式为： <code>struct</code>结构体名{ 结构体所包含的变量或数组 };</p><p>结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的<strong>成员</strong>（Member）。请看下面的一个例子：</p><p><code>struct stu&#123;     char *name;  //姓名，由于是不改变的字符串，声明为指针     int num;  //学号     int age;  //年龄     char group;  //所在学习小组     float score;  //成绩 &#125;;</code><code>stu</code> 为结构体名，它包含了 5 个成员，分别是<code>name、num、age、group、score;</code>结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。注意大括号后面的分号不能少，这是一条完整的语句。结构体也是一种数据类型，它由程序员自己定义，可以包含多个其他类型的数据。</p><p>像 int、float、char等是由C语言本身提供的数据类型，不能再进行分拆，我们称之为<strong>基本数据类型</strong>；而结构体可以包含多个基本类型的数据，也可以包含其他的结构体，我们将它称为<strong>复杂数据类型</strong>或<strong>构造数据类型</strong>。## 结构体变量 既然结构体是一种数据类型，那么就可以用它来定义变量。例如：<code>struct stu stu1, stu2;</code> 定义了两个变量 <code>stu1</code>和<code>stu2，</code>它们都是 stu 类型，都由 5 个成员组成。注意关键字struct 不能少。</p><p><code>stu</code>就像一个“模板”，定义出来的变量都具有相同的性质。也可以将结构体比作“图纸”，将结构体变量比作“零件”，根据同一张图纸生产出来的零件的特性都是一样的。</p><p>也可以在定义结构体的同时定义结构体变量：</p><p><code>struct stu&#123;     char *name;  //姓名     int num;  //学号     int age;  //年龄     char group;  //所在学习小组     float score;  //成绩 &#125; stu1, stu2;</code></p><p>将变量放在结构体定义的最后即可。</p><p>也可以直接对结构体变量初始化；</p><p><code>struct stu&#123;     char *name;  //姓名     int num;  //学号     int age;  //年龄     char group;  //所在学习小组     float score;  //成绩 &#125; stu1=&#123;"Tom",12,18,'A',136.5&#125;;</code></p><h2 id="成员的获取和赋值">成员的获取和赋值</h2><p>结构体和数组类似，也是一组数据的集合，整体使用没有太大的意义。数组使用下标<code>[ ]</code> 获取单个元素，结构体使用点号 <code>.</code>获取单个成员。获取结构体成员的一般格式为：</p><p><strong>结构体变量名.成员名;</strong></p><p>通过这种方式可以获取成员的值，也可以给成员赋值，例如：</p><p><code>#include &lt;stdio.h&gt; int main()&#123;     struct&#123;         char *name;  //姓名         int num;  //学号         int age;  //年龄         char group;  //所在小组         float score;  //成绩     &#125; stu1;     //给结构体成员赋值     stu1.name = "Tom";     stu1.num = 12;     stu1.age = 18;     stu1.group = 'A';     stu1.score = 136.5;     //读取结构体成员的值     printf("%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n", stu1.name, stu1.num, stu1.age, stu1.group, stu1.score);     return 0; &#125;</code></p><p>运行结果： Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！</p><h2 id="结构体嵌套">结构体嵌套</h2><p>可以把一种结构体嵌套在另一个结构体中，例如：</p><p><code>int main()&#123;     struct person_name&#123;         char *firstname;         char *lastname;     &#125;;     struct stu&#123;         struct person_name name;  //姓名         int num;  //学号         int age;  //年龄         char group;  //所在小组         float score;  //成绩     &#125;;     struct stu student1;     student1.name.firstname="Issac";     student1.name.lastname="Newton";     printf("%s %s",student1.name.firstname,student1.name.lastname);     return 0; &#125;</code></p><p>访问2层嵌套的结构体要用两次.运算符；</p><p>使name成为结构的好处之一就是可以把name作为数据单元来处理；这样操作起来更容易，例如，如果打算编写函数来显示名字，那么只需要传递一个实参（person_name结构）而非三个参数：</p><p><code>display(student1.name);</code></p><p>同样，把信息从结构person_name复制给结构stu的成员name将只需要一次赋值：</p><p><code>struct person_name new_name;</code></p><p><code>student1.name=new_name;</code></p><h2 id="结构数组">结构数组</h2><p>结构数组即元素为结构体的数组；</p><h1 id="链表">链表</h1><p>链表是由一连串的结构（称为结点）组成的，其中每个结点都包含指向链表中下一个结点的指针；链表的最后一个结点包含一个空指针；</p><h2 id="链表与数组的比较">链表与数组的比较</h2><p>数组和链表是数据结构的两种存储方式：顺序存储和链式存储；链表的优点在于：我们可以很容易地在链表中插入和删除结点，即允许链表根据需要扩大和缩小；而数组的优点在于能够随机访问数组中的元素，访问链表中的元素则和结点与链表的起始处的距离有关，如果结点距离链表的起始处近，则访问时间较短，反之访问时间较长；</p><h2 id="链表的建立">链表的建立</h2><h3 id="声明结点类型">声明结点类型</h3><p>为了建立链表，首先需要一个表示表中单个结点的结构；结点应包含<strong>数据</strong>和<strong>指向下一个结点的指针</strong>；</p><p><code>struct node&#123;</code></p><p><code>int value;</code></p><p><code>struct node *next;</code></p><p><code>&#125;Node;</code></p><h3 id="创建结点">创建结点</h3><p>包括三个步骤：</p><ol type="1"><li>为结点分配内存单元；</li><li>把数据存储到结点中；</li><li>把结点插入链表中；</li></ol><h2 id="链表操作">链表操作</h2><h3 id="插入结点">插入结点</h3><p>在链表中插入新元素，</p><h1 id="文件操作">文件操作</h1><h2 id="读写">读写</h2><p>读就是从文件里获取数据，写则是将数据写入文件里。在完成对一个文件的读写操作之后，<strong>必须将其关闭</strong>。</p><p>fopen函数用于打开一个文件；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>FILE *fp;<br><span class="hljs-type">int</span> ch;<br><span class="hljs-keyword">if</span>((fp=fopen(<span class="hljs-string">&quot;hello.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>))==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><span class="hljs-keyword">while</span>((ch=getc(fp))!=EOF)<br>&#123;<br><span class="hljs-built_in">putchar</span>(ch);<br>&#125;<br>fclose(fp);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该文件夹下若含有名为hello.txt的文件，则输出其中的内容；若没有此文件，输出error；</p><p>使用fprintf函数将内容写入指定文件，使用<code>fopen("date.txt","w")</code>打开名为date的文件（如果没有此文件则会创建一个名为date的文件），并写入内容；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>FILE *fp;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">p</span>;</span><br><span class="hljs-type">time_t</span> t;<br>time(&amp;t);<br>p=localtime(&amp;t);<br><span class="hljs-keyword">if</span>((fp=fopen(<span class="hljs-string">&quot;date.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>))==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;%d-%d-%d&quot;</span>,<span class="hljs-number">1900</span>+p-&gt;tm_year,<span class="hljs-number">1</span>+p-&gt;tm_mon,p-&gt;tm_mday);<br>fclose(fp);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，将计算机日期写入名为date的文件，这个文件包含在源代码所在的文件夹中；</p><h3 id="fseek函数">fseek函数</h3><p>用法：<code>int fseek(FILE *stream, long offset, int fromwhere);</code>第一个参数stream为文件指针第二个参数offset为偏移量，整数表示正向偏移，负数表示负向偏移第三个参数fromwhere设定从文件的哪里开始偏移，可能取值为：SEEK_CUR、SEEK_END或 SEEK_SET 0 / SEEK_SET：文件开头 1 / SEEK_CUR：当前位置 2 /SEEK_END：文件结尾 简言之： fseek(fp, 100L, 0);把fp指针移动到离文件开头100字节处； fseek(fp, 100L, 1);把fp指针移动到离文件当前位置100字节处； fseek(fp, 100L, 2);把fp指针退回到离文件结尾100字节处。</p><h3 id="getc函数">getc函数</h3><p><strong>int getc(FILE *stream)</strong> 从指定的流 stream获取下一个字符（一个无符号字符），并把位置标识符往前移动。</p><h1 id="头文件">头文件</h1><h2 id="time.h头文件">&lt;time.h&gt;头文件</h2><p>time函数返回当前的日历时间，</p><h2 id="stdlib.h头文件">&lt;stdlib.h&gt;头文件</h2><p>standard library，标准库头文件</p><h3 id="malloc函数-1">malloc函数</h3><p>原型：void*malloc（size_tsize）;malloc函数向系统分配size个字节的内存空间，并返回一个指向这块空间的指针，但是并不对内存进行初始化；</p><ul><li>由于返回类型是void，所以它可以被转换成任何类型的数据，如果函数调用失败，返回值是NULL，如果size参数设置为0，返回值也可能是NULL；</li></ul><h3 id="system函数">system函数</h3><p>system是一个函数，用来运行外部的程序，格式为system(“命令语句”);</p><p>以下代码会打开计算器；</p><p><code>#include&lt;stdlib.h&gt; //加#include&lt;windows.h&gt;也可以 int main() &#123;     system("calc");     //打开计算器     return 0; &#125;</code></p><h2 id="windows.h头文件">&lt;windows.h&gt;头文件</h2><h3 id="坐标结构">坐标结构</h3><p>coord是来自&lt;windows.h&gt;中的一个函数，定义是表示文字在控制台的坐标，俗称<strong>坐标结构</strong></p><p><code>#include &lt;windows.h&gt;</code></p><p><code>typedef struct _COORD</code></p><p><code>&#123; short x;//这里是短整型</code></p><p><code>short y;</code></p><p><code>&#125;COORD;</code></p><h3 id="sleep函数">sleep函数</h3><p>sleep(int x)可以使程序在sleep函数位置暂停x毫秒；</p><h2 id="stdbool.h头文件">&lt;stdbool.h&gt;头文件</h2><p>bool型变量，若逻辑运算结果为真（true）则输出1；若为假（false）则输出0；例如</p><p><code>bool is_empty(void) &#123;   return top == 0; &#125;</code></p><p>如果top==0为真返回1；为假返回0；（==为判等运算符）</p><h3 id="伪随机数生成函数srand和rand">伪随机数生成函数srand和rand</h3><p>计算机并不能真正产生随机数，他只能根据<strong>种子</strong>的值通过一系列复杂运算给出一个貌似随机的数，种子就是最开始生成伪随机数的自变量，对于同一个函数，输入种子相同时，返回值也相同；</p><p>我们希望产生随机数，就要使每次的种子值不同，因此可以选择时间作为种子</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Programming</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
